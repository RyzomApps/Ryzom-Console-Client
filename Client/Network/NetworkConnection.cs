///////////////////////////////////////////////////////////////////
// This file contains modified code from 'Ryzom - MMORPG Framework'
// http://dev.ryzom.com/projects/ryzom/
// which is released under GNU Affero General Public License.
// http://www.gnu.org/licenses/
// Copyright 2010 Winch Gate Property Limited
///////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Threading;
using API.Helper;
using Client.Config;
using Client.Database;
using Client.Helper;
using Client.Network.Action;
using Client.Network.Proxy;
using Client.Property;
using Client.Stream;

namespace Client.Network
{
    /// <summary>
    /// Abstracts the connection client towards front-end
    /// handles incoming and outgoing messages from the game server and keeps track of the current state of the connection 
    /// </summary>
    public class NetworkConnection
    {
        public uint LastSentCycle;

        /// <summary>
        /// method used for incoming impulses
        /// </summary>
        internal Action<BitMemoryStream> ImpulseCallback;

        /// <summary>
        /// The UDP connection to the frontend
        /// </summary>
        private IUdpSocket _connection;

        /// <summary>
        /// The current state of the connection
        /// </summary>
        private ConnectionState _connectionState;

        /// <summary>
        /// Generic action multi part handling structures
        /// </summary>
        private readonly List<GenericMultiPartTemp> _genericMultiPartTemp = new List<GenericMultiPartTemp>();

        /// <summary>
        /// actions in sending buffer
        /// </summary>
        private readonly List<ActionBlock> _actions = new List<ActionBlock>();

        /// <summary>
        /// Changes since
        /// </summary>
        private readonly List<PropertyChange> _changes = new List<PropertyChange>();

        private readonly PropertyDecoder _propertyDecoder = new PropertyDecoder();

        #region Login Variables

        /// <summary>
        /// is the ipv4 address of the client in UINT
        /// </summary>
        private int _userAddr;

        /// <summary>
        /// is an UINT generated by the login_service at each login password verification
        /// </summary>
        private int _userKey;

        /// <summary>
        /// is an UINT unique for each account (an account could have more than one avatar)
        /// </summary>
        private int _userId;

        /// <summary>
        /// The address of the frontend service
        /// </summary>
        private string _frontendAddress;

        private int _loginAttempts;

        #endregion

        /// <summary>
        /// number that will be used to send the next packet
        /// </summary>
        private int _currentSendNumber;

        /// <summary>
        /// number of the last packet receive from the server
        /// </summary>
        private int _lastReceivedNumber;

        /// <summary>
        /// this mask contains ACK of old messages received by the server
        /// </summary>
        private uint _ackBitMask;

        /// <summary>
        /// a remember of the status of the previous received packet
        /// </summary>
        private uint _lastAckBit;

        private uint _synchronize;

        private int _lastAckInLongAck;

        private long _latestLoginTime;
        private uint _latestSync;
        private long _latestSyncTime;
        private long _latestProbeTime;
        private long _updateTime;
        private long _lastSendTime;

        private int _totalMessages;

        VisualPropertyNodeClient _visualPropertyTreeRoot;

        /// <summary>
        /// the time currently played at this frame (in the past)
        /// </summary>
        private long _currentClientTime;

        /// <summary>
        /// the tick for the current frame (in the past)
        /// </summary>
        private uint _currentClientTick;

        /// <summary>
        /// the last tick sent by the server
        /// </summary>
        private uint _currentServerTick;

        /// <summary>
        /// Lag Compensation Time in ms (default: 1000)
        /// </summary>
        private int _lct;

        /// <summary>
        /// Was the header decoded for the last received message?
        /// </summary>
        private bool _decodedHeader;

        /// <summary>
        /// The message is in system mode
        /// </summary>
        private bool _systemMode;

        /// <summary>
        /// The received number lastly decoded
        /// </summary>
        private int _currentReceivedNumber;

        private int _lastReceivedAck;
        private int _msPerTick;

        private bool _registered;
        private readonly List<int> _latestProbes = new List<int>();
        private int _latestProbe;

        private uint _quitId;

        private bool[] _longAckBitField = new bool[Constants.NumBitsInLongAck * 2];

        /// <summary>
        /// MD5 hash keys of msg.xml
        /// </summary>
        private byte[] _msgXmlMD5;

        /// <summary>
        /// MD5 hash keys of database.xml
        /// </summary>
        private byte[] _databaseXmlMD5;

        private bool _alreadyWarned;

        private long _previousTime;

        private long _latestQuitTime;
        private bool _receivedAckQuit;

        private byte _impulseMultiPartNumber;

        readonly Dictionary<uint, byte> _idMap = new Dictionary<uint, byte>();

        private static List<byte> _targetSlotsList = new List<byte>(256);

        /// <summary>
        /// /// Mean download (payload bytes)
        /// </summary>
        private readonly MeanComputer _meanDownload = new MeanComputer();

        /// <summary>
        /// /// Mean upload (payload bytes)
        /// </summary>
        private readonly MeanComputer _meanUpload = new MeanComputer();

        /// <summary>
        /// /// Mean packets
        /// </summary>
        private readonly MeanComputer _meanPackets = new MeanComputer(5000);

        /// <summary>
        /// Mean lost
        /// </summary>
        private readonly MeanComputer _meanLoss = new MeanComputer(5000);

        /// <summary>
        /// Uncorrected Ping
        /// </summary>
        private Queue<int> _ping = new Queue<int>(10);

        /// <summary>
        /// Main client reference
        /// </summary>
        private readonly RyzomClient _client;

        /// <summary>
        /// In game Database Manager
        /// </summary>
        private readonly DatabaseManager _databaseManager;

        /// <summary>
        /// Get the last tick sent by the server
        /// </summary>
        public uint GetCurrentServerTick() => _currentServerTick;

        /// <summary>
        /// last TPS check time
        /// </summary>
        private long _tickSectionTime = NanoTime();

        /// <summary>
        /// last TPS check tick
        /// </summary>
        private long _tickSectionTick;

        /// <summary>
        /// TPS last 1 minute
        /// </summary>
        internal RollingAverage Tps1 = new RollingAverage(60);

        /// <summary>
        /// TPS last 5 minutes
        /// </summary>
        internal RollingAverage Tps5 = new RollingAverage(60 * 5);

        /// <summary>
        /// TPS last 15 minutes
        /// </summary>
        internal RollingAverage Tps15 = new RollingAverage(60 * 15);

        /// <summary>
        /// Gets the current server TPS
        /// </summary>
        public double[] GetTps()
        {
            return new[] {
                Tps1.GetAverage(),
                Tps5.GetAverage(),
                Tps15.GetAverage()
            };
        }

        /// <summary>
        /// Set the last tick sent by the server
        /// </summary>
        /// <param name="tick">tick number</param>
        private void SetCurrentServerTick(uint tick)
        {
            _currentServerTick = tick;
            var curTime = NanoTime();

            if (_tickSectionTick == 0)
            {
                _tickSectionTick = _currentServerTick;
                _tickSectionTime = curTime;
            }

            if (_currentServerTick > _tickSectionTick + RollingAverage.GameTps)
            {
                var diff = curTime - _tickSectionTime;
                var currentTps = RollingAverage.SecInNano / diff * (_currentServerTick - _tickSectionTick);

                Tps1.Add(currentTps, diff);
                Tps5.Add(currentTps, diff);
                Tps15.Add(currentTps, diff);

                _tickSectionTime = curTime;
                _tickSectionTick = _currentServerTick;
            }
        }

        /// <summary>
        /// The current value of the system timer in nanoseconds.
        /// </summary>
        private static long NanoTime()
        {
            var nano = 10000L * Stopwatch.GetTimestamp();
            nano /= TimeSpan.TicksPerMillisecond;
            nano *= 100L;
            return nano;
        }

        /// <summary>
        /// Get the changes since last clear
        /// </summary>
        internal PropertyDecoder GetPropertyDecoder() { return _propertyDecoder; }

        /// <summary>
        /// Get the changes since last clear
        /// </summary>
        public List<PropertyChange> GetChanges() { return _changes; }

        /// <summary>
        /// Clear all changes
        /// </summary>
        public void ClearChanges() { _changes.Clear(); }

        /// <summary>
        /// Gets the connection state
        /// </summary>
        public ConnectionState ConnectionState
        {
            get => _connectionState;
            set
            {
                _client.GetLogger().Info($"Connection state changed to {value}");
                _connectionState = value;
            }
        }

        /// <summary>
        /// Return the country code of the proxy currently used. Empty string if no proxy is used.
        /// </summary>
        public string ProxyCountry { get; internal set; } = "";

        /// <summary>
        /// Constructor
        /// </summary>
        public NetworkConnection(RyzomClient client)
        {
            _connectionState = ConnectionState.NotInitialized;

            _client = client;
            _databaseManager = client.GetDatabaseManager();

            Reset();

            InitTicks();
        }

        /// <summary>
        /// Initialize the connection with the cookie from the login server and game server address - registers all action codes
        /// </summary>
        /// <param name="cookie">the cookie in string format that was passed as command line parameter (given by the nel_launcher)</param>
        /// <param name="addr">the front end address in string format that was passed as command line parameter (given by the nel_launcher)</param>
        public void Init(string cookie, string addr)
        {
            if (ConnectionState != ConnectionState.NotInitialized &&
                ConnectionState != ConnectionState.Disconnect)
            {
                throw new Exception("Unable to init(): connection not properly closed yet.");
            }

            if (!_registered)
            {
                ActionFactory.RegisterAction(ActionCode.ActionGenericCode, typeof(ActionGeneric));
                ActionFactory.RegisterAction(ActionCode.ActionDisconnectionCode, typeof(ActionDisconnection));
                ActionFactory.RegisterAction(ActionCode.ActionGenericMultiPartCode, typeof(ActionGenericMultiPart));
                ActionFactory.RegisterAction(ActionCode.ActionPositionCode, typeof(ActionPosition));
                ActionFactory.RegisterAction(ActionCode.ActionSint64, typeof(ActionLong));
                ActionFactory.RegisterAction(ActionCode.ActionTargetSlotCode, typeof(ActionTargetSlot));

                _registered = true;
            }

            // Register property nbbits
            ActionLong.RegisterNumericPropertiesRyzom();

            InitCookie(cookie, addr);

            // Initialize visual property tree
            _visualPropertyTreeRoot = new VisualPropertyNodeClient();
            _visualPropertyTreeRoot.BuildTree();

            // get md5 hashes
            _msgXmlMD5 = Misc.GetFileMD5("data/msg.xml"); // c9728a56c6852972e52b88a37b48fd8b
            _databaseXmlMD5 = Misc.GetFileMD5("data/database.xml"); // 09a464f8f35fd70af3e363b69cef6950
        }

        /// <summary>
        /// Sets the cookie and front-end address, resets the connection state.
        /// </summary>
        public void InitCookie(string cookie, string addr)
        {
            _frontendAddress = addr;

            SetLoginCookieFromString(cookie);

            _client.GetLogger().Info($"Network initialization with front end '{_frontendAddress}'");
            _client.GetLogger().Debug($"cookie {cookie}");

            ConnectionState = ConnectionState.NotConnected;
        }

        /// <summary>
        /// Reset of the packet data counters and times
        /// </summary>
        public void Reset()
        {
            _currentSendNumber = 0;
            _lastReceivedNumber = 0;
            _ackBitMask = 0;
            _lastAckBit = 0;

            _synchronize = 0;
            _lct = 100;

            _latestSync = 0;

            _propertyDecoder.Init(256);

            _longAckBitField = new bool[Constants.NumBitsInLongAck * 2];

            _lastAckInLongAck = 0;
            LastSentCycle = 0;

            _meanPackets.MeanPeriod = 5000;
            _meanLoss.MeanPeriod = 5000;

            _ping = new Queue<int>(10);
        }

        private void InitTicks()
        {
            _msPerTick = 100;
        }

        /// <summary>
        /// Connects to the front-end (using or not the login system, depending on what was specified at init())
        /// Start the connection state machine - Udp socket will connect at this point
        /// </summary>
        internal void Connect(bool proxied = false)
        {
            if (ConnectionState != ConnectionState.NotConnected)
            {
                throw new Exception(
                    "Unable to connect(): connection not properly initialized (maybe connection not closed).");
            }

            // S12: connect to the FES. Note: In UDP mode, it's the user that have to send the cookie to the front end
            try
            {
                if (proxied)
                {
                    _client.GetLogger().Info($"Trying to find a working UDP proxy. This could take a moment...");

                    _connection = ProxyManager.GetSocks5ProxyUdp(null, _frontendAddress);
                    ProxyCountry = IpInfoIo.GetUserCountryByIp(((UdpSocketProxied)_connection).HostName);

                    _client.GetLogger().Info($"Using proxy server '{((UdpSocketProxied)_connection).HostName}' for the game data.");
                }
                else
                {
                    _connection = new UdpSocket();
                    _connection.Connect(_frontendAddress);
                }
            }
            catch (Exception e)
            {
                throw new Exception("FS refused the connection (" + e.Message + ")");
            }

            ConnectionState = ConnectionState.Login;

            _latestLoginTime = Misc.GetLocalTime();
            _latestSyncTime = _latestLoginTime;
            _latestProbeTime = _latestLoginTime;
            _loginAttempts = 0;

            // reset TPS counters
            Tps1.Reset();
            Tps5.Reset();
            Tps15.Reset();
        }

        /// <summary>
        /// Sets the callback called when a generic impulse comes
        /// </summary>
        public void SetImpulseCallback(Action<BitMemoryStream> impulseCallBack)
        {
            ImpulseCallback = impulseCallBack;
        }

        /// <summary>
        /// Updates the whole connection with the frontend.
        ///
        /// Behavior in login state when a firewall does not grant the sending:
        /// - When a sending is refused (error "Blocking operation interrupted")
        /// the exception EBlockedByFirewall in thrown. The first time, a time-out is armed.
        /// - In a later attempt, if the time-out expired, the function sets state to
        /// Disconnect, then throws EBlockedByFirewall.
        ///
        /// tests the connection state and initializes the state machine
        /// </summary>
        /// <returns>True, if data was sent/received.</returns>
        public bool Update()
        {
            _updateTime = Misc.GetLocalTime();
            _totalMessages = 0;

            // If we are disconnected, bypass the real network update
            if (ConnectionState == ConnectionState.Disconnect)
            {
                return false;
            }

            // YOYO: OnUpdate the Smooth ServerTick.
            UpdateSmoothServerTick();

            if (!_connection.IsConnected())
            {
                throw new Exception("CNET: update() attempted whereas socket is not connected!");
            }

            try
            {
                // State automaton
                bool stateBroke;

                do
                {
                    stateBroke = ConnectionState switch
                    {
                        ConnectionState.Login =>
                            // if receives System SYNC
                            //    immediate state Synchronize
                            // else
                            //    sends System LoginCookie
                            StateLogin(),
                        ConnectionState.Synchronize =>
                            // if receives System PROBE
                            //    immediate state Probe
                            // else if receives Normal
                            //    immediate state Connected
                            // else
                            //    sends System ACK_SYNC
                            StateSynchronize(),
                        ConnectionState.Connected =>
                            // if receives System PROBE
                            //    immediate state Probe
                            // else if receives Normal
                            //	   sends Normal data
                            StateConnected(),
                        ConnectionState.Probe =>
                            // if receives System SYNC
                            //    immediate state SYNC
                            // else if receives System PROBE
                            //    decode PROBE
                            // sends System ACK_PROBE
                            StateProbe(),
                        ConnectionState.Stalled =>
                            // if receives System SYNC
                            //    immediate state SYNC
                            // else if receives System STALLED
                            //    decode STALLED (nothing to do)
                            // else if receives System PROBE
                            //    immediate state PROBE
                            StateStalled(),
                        ConnectionState.Quit =>
                            // if receives System SYNC
                            //    immediate state Synchronize
                            // else
                            //    sends System LoginCookie
                            StateQuit(),
                        _ => false
                    };
                } while (stateBroke); // && _TotalMessages<5);
            }
            catch (NetworkLoginException)
            {
                throw;
            }
            catch (Exception e)
            {
                _client.GetLogger().Error("Exception: " + e.Message);
                _connectionState = ConnectionState.Disconnect;
            }

            return _totalMessages != 0;
        }

        /// <summary>
        /// Connection state machine - Login state
        /// if receives System SYNC
        /// immediate state Synchronize
        /// else
        /// sends System LoginCookie
        /// </summary>
        private bool StateLogin()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync
                                ConnectionState = ConnectionState.Synchronize;
                                _client.GetLogger().Debug("CNET: login->synchronize");
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Stalled;
                                _client.GetLogger().Debug("CNET: login->stalled");
                                ReceiveSystemStalled();
                                return true;

                            case SystemMessageType.SystemProbeCode:
                                // receive probe, decode probe and state probe
                                ConnectionState = ConnectionState.Probe;
                                _changes.Add(new PropertyChange(0, (byte)PropertyType.ProbeReceived));
                                _client.GetLogger().Debug("CNET: login->probe");
                                ReceiveSystemProbe(msgin);
                                return true;

                            case SystemMessageType.SystemServerDownCode:
                                Disconnect(); // will send disconnection message
                                _client.GetLogger().Error("BACK-END DOWN");
                                return false; // exit now from loop, don't expect a new state

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Login");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET: received normal in state Login");
                    }
                }
            }

            // send ack sync if received sync or last sync timed out
            if (_updateTime - _latestLoginTime > 300)
            {
                SendSystemLogin();
                _latestLoginTime = _updateTime;

                if (_loginAttempts > 24)
                {
                    _loginAttempts = 0;
                    // will send disconnection message
                    Disconnect();
                    //_client.GetLogger().Warn("CNET: Too many LOGIN attempts, connection problem");
                    //// exit now from loop, don't expect a new state
                    //return true;
                    throw new NetworkLoginException("CNET: Too many LOGIN attempts, connection problem");
                }

                ++_loginAttempts;
            }

            return false;
        }

        /// <summary>
        /// Connection state machine - Probe State
        /// if receives System SYNC
        /// immediate state SYNC
        /// else if receives System PROBE
        /// decode PROBE
        /// sends System ACK_PROBE
        /// </summary>
        private bool StateProbe()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync and state synchronize
                                ConnectionState = ConnectionState.Synchronize;
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive sync, decode sync and state synchronize
                                ConnectionState = ConnectionState.Stalled;
                                ReceiveSystemStalled();
                                return true;

                            case SystemMessageType.SystemProbeCode:
                                // receive sync, decode sync
                                ReceiveSystemProbe(msgin);
                                break;

                            case SystemMessageType.SystemServerDownCode:
                                // will send disconnection message
                                Disconnect();
                                _client.GetLogger().Error("BACK-END DOWN");
                                // exit now from loop, don't expect a new state
                                return false;

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Probe");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET: received normal in state Probe");
                        _latestProbeTime = _updateTime;
                    }
                }
            }

            // send ack sync if received sync or last sync timed out
            if (_latestProbes.Count != 0 || _updateTime - _latestProbeTime > 300)
            {
                SendSystemAckProbe();
                _latestProbeTime = _updateTime;
            }
            else
                Thread.Sleep(10);

            return false;
        }

        /// <summary>
        /// Connection state machine - Synchronize State
        /// if receives System PROBE
        /// immediate state Probe
        /// else if receives Normal
        /// immediate state Connected
        /// sends System ACK_SYNC
        /// </summary>
        private bool StateSynchronize()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemProbeCode:
                                // receive probe, decode probe and state probe
                                ConnectionState = ConnectionState.Probe;
                                _changes.Add(new PropertyChange(0, (byte)PropertyType.ProbeReceived));
                                ReceiveSystemProbe(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Stalled;
                                ReceiveSystemStalled();
                                return true;

                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync
                                ReceiveSystemSync(msgin);
                                break;

                            case SystemMessageType.SystemServerDownCode:
                                // will send disconnection message
                                Disconnect();
                                _client.GetLogger().Error("BACK-END DOWN");
                                // exit now from loop, don't expect a new state
                                return false;

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Synchronize");
                                break;
                        }
                    }
                    else
                    {
                        ConnectionState = ConnectionState.Connected;

                        _changes.Add(new PropertyChange(0, (byte)PropertyType.ConnectionReady));

                        ImpulseDecoder.Reset();

                        ReceiveNormalMessage(msgin);

                        return true;
                    }
                }
            }

            // send ack sync if received sync or last sync timed out
            if (_updateTime - _latestSyncTime > 300)
                SendSystemAckSync();

            return false;
        }

        /// <summary>
        /// Connection state machine - Connected State
        /// if receives System PROBE
        /// immediate state Probe
        /// else if receives Normal
        /// sends Normal data
        /// </summary>
        private bool StateConnected()
        {
            // Prevent to increment the client time when the front-end does not respond
            var now = Misc.GetLocalTime();
            var diff = now - _previousTime;
            _previousTime = Misc.GetLocalTime();

            if (diff > 3000 && !_connection.IsDataAvailable())
            {
                return false;
            }

            // update the current time;
            while (_currentClientTime < _updateTime - _msPerTick - _lct &&
                   _currentClientTick < _currentServerTick)
            {
                _currentClientTime += _msPerTick;

                _currentClientTick++;
            }

            if (_currentClientTick >= _currentServerTick && !_connection.IsDataAvailable())
            {
                return false;
            }

            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemProbeCode:
                                // receive probe, and goto state probe
                                ConnectionState = ConnectionState.Probe;

                                _changes.Add(new PropertyChange(0, (byte)PropertyType.ProbeReceived));
                                ReceiveSystemProbe(msgin);
                                return true;

                            case SystemMessageType.SystemSyncCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Synchronize;
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Stalled;
                                ReceiveSystemStalled();
                                return true;

                            case SystemMessageType.SystemServerDownCode:
                                // will send disconnection message
                                Disconnect();
                                _client.GetLogger().Error("BACK-END DOWN");
                                // exit now from loop, don't expect a new state
                                return false;

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Connected");
                                break;
                        }
                    }
                    else
                    {
                        ReceiveNormalMessage(msgin);
                    }
                }
            }

            return false;
        }


        /// <summary>
        /// Connection state machine - Stalled State
        /// if receives System SYNC
        ///    immediate state SYNC
        /// else if receives System STALLED
        ///    decode STALLED (nothing to do)
        /// else if receives System PROBE
        ///    immediate state PROBE
        /// </summary>
        private bool StateStalled()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync and state synchronize
                                _connectionState = ConnectionState.Synchronize;
                                _client.GetLogger().Debug("CNET: stalled->synchronize");
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemProbeCode:
                                // receive sync, decode sync
                                _connectionState = ConnectionState.Probe;
                                _client.GetLogger().Debug("CNET: stalled->probe");
                                ReceiveSystemProbe(msgin);
                                break;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled
                                ReceiveSystemStalled();
                                break;

                            case SystemMessageType.SystemServerDownCode:
                                Disconnect(); // will send disconnection message
                                _client.GetLogger().Error("BACK-END DOWN");
                                return false; // exit now from loop, don't expect a new state

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Stalled");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET: received normal in state Stalled");
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Connection state machine - Quit State
        /// </summary>
        private bool StateQuit()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync and state synchronize
                                Reset();
                                _connectionState = ConnectionState.Synchronize;
                                _client.GetLogger().Debug("CNET: quit->synchronize");
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemServerDownCode:
                                Disconnect(); // will send disconnection message
                                _client.GetLogger().Error("BACK-END DOWN");
                                return false; // exit now from loop, don't expect a new state

                            case SystemMessageType.SystemAckQuitCode:
                                // receive ack quit -> reset connection state
                                ReceiveSystemAckQuit();
                                break;

                            default:
                                _client.GetLogger().Warn($"CNET received system {message} in state Quit");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET received normal in state Stalled");
                    }
                }
            }

            // send quit if not yet received a ack quit
            if (!_receivedAckQuit && _updateTime - _latestQuitTime > 100)
            {
                SendSystemQuit();
                _latestQuitTime = _updateTime;
            }

            return false;
        }

        /// <summary>
        /// Quit state
        /// </summary>
        private void ReceiveSystemAckQuit()
        {
            _client.GetLogger().Debug("CNET: received ACK_QUIT");
            _receivedAckQuit = true;
        }

        /// <summary>
        /// Receive and extract a normal (non system) message from a stream
        /// </summary>
        private void ReceiveNormalMessage(BitMemoryStream msgin)
        {
            _client.GetLogger().Debug($"CNET: received normal message Packet={_lastReceivedNumber} Ack={_lastReceivedAck}");
            _client.GetLogger().Debug($"{msgin}");

            var actions = new List<ActionBase>();
            ImpulseDecoder.Decode(msgin, _currentReceivedNumber, _lastReceivedAck, _currentSendNumber, actions);

            // we can now remove all old action that are acked
            while (_actions.Count != 0 && _actions[0].FirstPacket != 0 && _actions[0].FirstPacket <= _lastReceivedAck)
            {
                // CActionBlock automatically remove() actions when deleted
                _client.GetLogger().Debug($"removed action {_actions[0].FirstPacket}");
                _actions.RemoveAt(0);
            }

            Debug.Assert(_currentReceivedNumber * 2 + _synchronize > _currentServerTick);
            SetCurrentServerTick((uint)(_currentReceivedNumber * 2 + _synchronize));

            // TODO: receiveNormalMessage PacketStamps implementation

            // get the send time of the acknowledged packet
            var ackedPacketTime = Math.Max(_latestLoginTime, Math.Max(_latestSyncTime, Math.Max(_latestProbeTime, _lastSendTime)));

            // update ping
            while (_ping.Count >= 10)
                _ping.Dequeue();

            _ping.Enqueue((int)(_updateTime - ackedPacketTime));

            // Decode the actions received in the impulsions
            foreach (var action in actions)
            {
                switch (action.Code)
                {
                    case ActionCode.ActionDisconnectionCode:
                        // Self disconnection
                        _client.GetLogger().Warn("You were disconnected by the server");
                        // will send disconnection message
                        Disconnect();
                        break;

                    case ActionCode.ActionGenericCode:
                        GenericAction((ActionGeneric)action);
                        break;

                    case ActionCode.ActionGenericMultiPartCode:
                        GenericAction((ActionGenericMultiPart)action);
                        break;

                    case ActionCode.ActionDummyCode:
                        _client.GetLogger().Debug($"CNET Received Dummy {action}");
                        // Nothing to do
                        break;
                }

                ActionFactory.Remove(action);
            }

            // Decode the visual properties
            DecodeVisualProperties(msgin);
        }

        /// <summary>
        /// extract properties (database, sheets, ...) from a stream
        /// </summary>
        private void DecodeVisualProperties(BitMemoryStream msgin)
        {
            if (!ClientConfig.DecodeVisualProperties)
                return;

            try
            {
                var loop = 0;

                while (true)
                {
                    // Check if there is a new block to read - sizeof(TCLEntityId) => sizeof(uint8) = 1 byte
                    // 8 bit slot, 2 bit assoc, 1 timestamp, 16 bit unit timestamp, 2x payload bit
                    // 12 bit since the msgin stream is a byte and not a bit stream
                    if (msgin.GetPosInBit() + 12 > msgin.Length * 8)
                        return;

                    // Header
                    byte slot = 0;
                    msgin.Serial(ref slot); // 1

                    uint associationBits = 0;
                    msgin.Serial(ref associationBits, 2); // 2

                    if (AssociationBitsHaveChanged(slot, associationBits) /*&& slot == 0*/)
                    {
                        //displayBitStream( msgin, beginbitpos, msgin.getPosInBit() );
                        _client.Log.Debug($"Disassociating S{(ushort)slot}u (AB {associationBits}) L {loop}");

                        if (_propertyDecoder.IsUsed(slot))
                        {
                            var sheet = _propertyDecoder.Sheet(slot);

                            if (!_idMap.ContainsKey(sheet))
                                _idMap.Remove(sheet);

                            _propertyDecoder.RemoveEntity(slot);

                            var theChange = new PropertyChange(slot, (byte)PropertyType.RemoveOldEntity);
                            _changes.Add(theChange);

                            //if (slot == 1 || slot == 3 || slot == 7 || slot == 14 || slot == 29 || slot == 58 || slot == 117 || slot == 235 || slot == 255)
                            //    _client.Log.Info($"Disassociating S{(ushort)slot}u (AB {associationBits}) L {loop}");
                        }
                        else
                        {
                            _client.Log.Debug($"Cannot disassociate slot {(ushort)slot}u (AB {associationBits}): sheet not received yet");
                        }
                    }

                    // Read the timestamp delta if there's one (otherwise take _CurrentServerTick)
                    uint timestamp;
                    var timestampIsThere = false;
                    msgin.Serial(ref timestampIsThere); // 1

                    if (timestampIsThere)
                    {
                        uint timestampDelta = 0;
                        msgin.Serial(ref timestampDelta, 4);
                        timestamp = _currentServerTick - timestampDelta;
                        //_client.GetLogger().Debug( "TD: %u (S%hu)", timestampDelta, (uint16)slot );
                    }
                    else
                    {
                        timestamp = _currentServerTick;
                    }

                    //_client.Log.Info($"slot {slot} AB: {associationBits} timestamp: {timestamp}");

                    // Tree

                    var currentNode = _visualPropertyTreeRoot;

                    msgin.Serial(ref currentNode.A().BranchHasPayload); // 1

                    if (currentNode.A().BranchHasPayload)
                    {
                        var ap = (ActionPosition)ActionFactory.Create(slot, ActionCode.ActionPositionCode);

                        ap.Unpack(msgin);
                        _propertyDecoder.Receive(_currentReceivedNumber, ap);

                        // Set into property database
                        if (ap.Position[0] == 0 || ap.Position[1] == 0)
                        {
                            _client.Log.Warn($"S{(ushort)slot}u: Receiving an invalid position");
                        }

                        var nodeRoot = (DatabaseNodeBranch)_databaseManager?.GetNodePtr().GetNode(0);

                        if (nodeRoot != null)
                        {
                            var node = (DatabaseNodeLeaf)nodeRoot.GetNode(slot).GetNode(0);
                            Debug.Assert(node != null);
                            node.SetValue64(ap.Position[0]);

                            node = (DatabaseNodeLeaf)nodeRoot.GetNode(slot).GetNode(1);
                            Debug.Assert(node != null);
                            node.SetValue64(ap.Position[1]);

                            node = (DatabaseNodeLeaf)nodeRoot.GetNode(slot).GetNode(2);
                            Debug.Assert(node != null);
                            node.SetValue64(ap.Position[2]);

                            _client.Log.Debug($"recvd position ({ap.Position[0]}, {ap.Position[1]}) for slot {(ushort)slot}u, date {timestamp}u L {loop}");
                        }

                        var interior = ap.Interior;

                        ActionFactory.Remove(ap);

                        // TODO: Statistical prediction of time before next position update: set PredictedInterval

                        // Add into the changes vector
                        var thechange = new PropertyChange(slot, (byte)PropertyType.Position, timestamp)
                        {
                            PositionInfo = { PredictedInterval = 2, IsInterior = interior }
                        };

                        _changes.Add(thechange);
                    }

                    currentNode = currentNode.B();
                    msgin.Serial(ref currentNode.BranchHasPayload); // 1

                    if (currentNode.BranchHasPayload)
                    {
                        msgin.Serial(ref currentNode.A().BranchHasPayload); // 1

                        if (currentNode.A().BranchHasPayload)
                        {
                            var ac = (ActionLong)ActionFactory.CreateByPropIndex(slot, (byte)PropertyType.Orientation);
                            ac.Unpack(msgin);

                            // Process orientation
                            var thechange = new PropertyChange(slot, (byte)PropertyType.Orientation, timestamp);
                            _changes.Add(thechange);

                            var nodeRoot = (DatabaseNodeBranch)_databaseManager?.GetNodePtr().GetNode(0);

                            if (nodeRoot != null)
                            {
                                var node = (DatabaseNodeLeaf)(nodeRoot.GetNode(slot).GetNode((byte)PropertyType.Orientation));
                                Debug.Assert(node != null);
                                node.SetValue64(ac.GetValue());

                                _client.Log.Debug($"CLIENT: recvd property {(byte)PropertyType.Orientation}u ({PropertyType.Orientation}) for slot {(ushort)slot}u, date {timestamp} L {loop}");
                            }

                            ActionFactory.Remove(ac);
                        }

                        VisualPropertyNodeClient.SlotContext.NetworkConnection = this;
                        VisualPropertyNodeClient.SlotContext.Slot = slot;
                        VisualPropertyNodeClient.SlotContext.Timestamp = timestamp;

                        // Discreet properties
                        currentNode.B().DecodeDiscreteProperties(msgin);
                    }

                    loop++;
                }
            }
            catch (Exception e)
            {
                // End of stream (saves useless bits)
                _client.Log.Debug($"End of stream (saves useless bits) {e.Message}:\r\n{msgin.DebugData}");
            }
        }

        /// <summary>
        /// Checks if the association bits for the slot have changed
        /// </summary>
        private bool AssociationBitsHaveChanged(byte slot, uint associationBits)
        {
            var res = (ushort)associationBits != _propertyDecoder.GetAssociationBits(slot);
            _propertyDecoder.SetAssociationBits(slot, (ushort)associationBits);
            return res;
        }

        /// <summary>
        /// manage a generic action - invoke the impulse callback for the action
        /// </summary>
        private void GenericAction(ActionGeneric ag)
        {
            var bms = ag.Get();

            ImpulseCallback?.Invoke(bms);
        }

        /// <summary>
        /// manage a generic multi part action - generate temporary multipart holder until the action is complete
        /// </summary>
        /// <param name="agmp"></param>
        private void GenericAction(ActionGenericMultiPart agmp)
        {
            while (_genericMultiPartTemp.Count <= agmp.Number)
            {
                _genericMultiPartTemp.Add(new GenericMultiPartTemp());
            }

            _genericMultiPartTemp[agmp.Number].Set(agmp, this);
        }

        /// <summary>
        /// Probe state - deserialise info from stream
        /// </summary>
        private void ReceiveSystemProbe(BitMemoryStream msgin)
        {
            _latestProbeTime = _updateTime;
            msgin.Serial(ref _latestProbe);
            _latestProbes.Add(_latestProbe);
        }

        /// <summary>
        /// Stalled state - Sympathize with your machinery
        /// </summary>
        private void ReceiveSystemStalled()
        {
            _client.GetLogger().Debug("CNET: received STALLED");
        }

        /// <summary>
        /// Sync state - deserialize info from stream - send ack
        /// </summary>
        private void ReceiveSystemSync(BitMemoryStream msgin)
        {
            _latestSyncTime = _updateTime;
            long stime = 0;
            msgin.Serial(ref _synchronize);
            msgin.Serial(ref stime);
            msgin.Serial(ref _latestSync);

            _client.GetLogger().Debug($"receiveSystemSync {msgin}");

            var checkMsgXml = new byte[16]; // 16  8
            var checkDatabaseXml = new byte[16];

            msgin.Serial(ref checkMsgXml);
            msgin.Serial(ref checkDatabaseXml);

            var xmlInvalid = !checkMsgXml.SequenceEqual(_msgXmlMD5) || !checkDatabaseXml.SequenceEqual(_databaseXmlMD5);

            if (xmlInvalid && !_alreadyWarned)
            {
                _alreadyWarned = true;
                _client.GetLogger().Warn("XML files invalid: msg.xml and database.xml files are invalid (server version signature is different)");

                _client.GetLogger().Warn($"msg.xml client:{Misc.ByteArrToString(_msgXmlMD5)} server:{Misc.ByteArrToString(checkMsgXml)}");
                _client.GetLogger().Warn($"database.xml client:{Misc.ByteArrToString(_databaseXmlMD5)} server:{Misc.ByteArrToString(checkDatabaseXml)}");
            }

            _msPerTick = 100;

            //SetCurrentServerTick((uint)(_synchronize + _currentReceivedNumber * 2));
            _currentServerTick = (uint)(_synchronize + _currentReceivedNumber * 2);

            _currentClientTick = (uint)(_currentServerTick - (_lct + _msPerTick) / _msPerTick);
            _currentClientTime = _updateTime - (_lct + _msPerTick);

            SendSystemAckSync();
        }

        /// <summary>
        /// Receive available data and convert it to a BitMemoryStream
        /// </summary>
        private bool BuildStream(BitMemoryStream msgin)
        {
            var receiveBuffer = Array.Empty<byte>();

            if (_connection.Receive(ref receiveBuffer, false))
            {
                StatsReceive(receiveBuffer.Length);

                msgin.MemCpy(receiveBuffer);

                return true;
            }

            // A receiving error means the front-end is down
            ConnectionState = ConnectionState.Disconnect;

            // won't send a disconnection msg because state is already Disconnect
            Disconnect();

            _client.GetLogger().Error("Socket caused an exception. This error could mean, that the front-end, the proxy or the connection is down.");
            return false;
        }

        /// <summary>
        /// decode the message header from the stream
        /// </summary>
        private bool DecodeHeader(BitMemoryStream msgin, bool checkMessageNumber = true)
        {
            if (_decodedHeader)
                return true;

            ++_totalMessages;

            msgin.Serial(ref _currentReceivedNumber);
            msgin.Serial(ref _systemMode);

            _meanPackets.Update(_currentReceivedNumber, Misc.GetLocalTime());

            if (!_systemMode)
            {
                msgin.Serial(ref _lastReceivedAck);
            }

            if (!checkMessageNumber)
                return true;

            // todo doesn't work if we receive the packet in bad order or 2 same packet
            if (_currentReceivedNumber > _lastReceivedNumber + 1)
            {
                // we lost some messages...
                _client.Log.Debug($"CNET: lost messages server->client [{_lastReceivedNumber + 1};{_currentReceivedNumber - 1}]");
                _meanLoss.Update(_currentReceivedNumber - _lastReceivedNumber - 1, Misc.GetLocalTime());
            }

            // don't acknowledge system messages and normal messages in
            // because this will disturb impulsion from frontend, that will interpret it as if previous messages were ok
            var ackBool = (!_systemMode && (_connectionState == ConnectionState.Connected || _connectionState == ConnectionState.Synchronize));
            var ackBit = (ackBool ? (uint)1 : 0);

            if (_currentReceivedNumber - _lastReceivedNumber < 32)
            {
                _ackBitMask <<= _currentReceivedNumber - _lastReceivedNumber;
                _ackBitMask |= _lastAckBit << (_currentReceivedNumber - _lastReceivedNumber - 1);
            }
            else
            {
                _ackBitMask = (_currentReceivedNumber - _lastReceivedNumber == 32 && _lastAckBit != 0)
                    ? 0x80000000
                    : 0x00000000;
            }

            _lastAckBit = ackBit;

            // encode long ack bitfield
            for (var i = _lastReceivedNumber + 1; i < _currentReceivedNumber; ++i)
                _longAckBitField[i & (Constants.NumBitsInLongAck - 1)] = false;

            _longAckBitField[_currentReceivedNumber & (Constants.NumBitsInLongAck - 1)] = ackBool;

            // no more than NumBitsInLongAck ack in field
            if (_lastAckInLongAck <= _currentReceivedNumber - Constants.NumBitsInLongAck)
                _lastAckInLongAck = _currentReceivedNumber - Constants.NumBitsInLongAck + 1;

            _lastReceivedNumber = _currentReceivedNumber;

            _decodedHeader = true;

            return true;
        }

        /// <summary>
        /// Disconnects the Client from the server sending a disconnection packet
        /// </summary>
        public void Disconnect()
        {
            if (ConnectionState == ConnectionState.NotInitialized ||
                ConnectionState == ConnectionState.NotConnected ||
                ConnectionState == ConnectionState.Authenticate ||
                ConnectionState == ConnectionState.Disconnect)
            {
                _client.GetLogger().Warn("Unable to disconnect: Not connected yet or already disconnected.");
                ConnectionState = ConnectionState.Disconnect;
                return;
            }

            SendSystemDisconnection();
            _connection.Close();
            ConnectionState = ConnectionState.Disconnect;
        }

        /// <summary>
        /// sends system sync acknowledgement
        /// </summary>
        private void SendSystemAckSync()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            var sync = (byte)SystemMessageType.SystemAckSyncCode;
            message.Serial(ref sync); // 8
            message.Serial(ref _lastReceivedNumber); // 32
            message.Serial(ref _lastAckInLongAck); // 32

            message.SerialVersion(0); // 8
            var size = (uint)_longAckBitField.Length;
            message.Serial(ref size); // 32
            var len = (int)(size / 32);
            message.Serial(ref len); // 32
            message.Serial(ref _longAckBitField); // 1024

            message.Serial(ref _latestSync); // 32

            _client.GetLogger().Debug($"sendSystemAckSync {message}");

            _connection.Send(message.Buffer(), message.Length);

            _latestSyncTime = _updateTime;

            StatsSend(message.Length);
        }

        /// <summary>
        /// sends system Probe acknowledge
        /// </summary>
        private void SendSystemAckProbe()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            var probe = (byte)SystemMessageType.SystemAckProbeCode;
            var numprobes = _latestProbes.Count;

            message.Serial(ref probe);
            message.Serial(ref numprobes);

            for (var i = 0; i < numprobes; ++i)
            {
                var val = _latestProbes[i];
                message.Serial(ref val);
            }

            _latestProbes.Clear();

            _connection.Send(message.Buffer(), message.Length);

            StatsSend(message.Length);
        }

        /// <summary>
        /// sends system Disconnection acknowledge
        /// </summary>
        private void SendSystemDisconnection()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            byte disconnection = (byte)SystemMessageType.SystemDisconnectionCode;

            message.Serial(ref disconnection);

            if (_connection.IsConnected())
            {
                try
                {
                    _client.GetLogger().Debug($"sendSystemDisconnection {message}");

                    _connection.Send(message.Buffer(), message.Length);
                    StatsSend(message.Length);
                }
                catch (Exception e)
                {
                    _client.GetLogger().Error($"Socket exception: {e.Message}");
                }
            }

            StatsSend(message.Length);
        }

        /// <summary>
        /// sends system quit acknowledgement
        /// </summary>
        private void SendSystemQuit()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            var quit = (byte)SystemMessageType.SystemQuitCode;

            message.Serial(ref quit);
            message.Serial(ref _quitId);

            _connection.Send(message.Buffer(), message.Length);

            ++_quitId; // we do that here instead of in the quit() method
            StatsSend(message.Length);

            _client.GetLogger().Info("CNET: sent QUIT");
        }

        /// <summary>
        /// sends system login cookie
        /// </summary>
        public void SendSystemLogin()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            byte login = (byte)SystemMessageType.SystemLoginCode;
            message.Serial(ref login);

            // Cookie
            message.Serial(ref _userAddr);
            message.Serial(ref _userKey);
            message.Serial(ref _userId);

            // Language
            message.Serial(ref ClientConfig.LanguageCode);

            _client.GetLogger().Debug($"sendSystemLogin {message}");
            _connection.Send(message.Buffer(), message.Length);

            StatsSend(message.Length);
        }

        /// <summary>
        /// Sets the cookie for the connection
        /// </summary>
        private void SetLoginCookieFromString(string str)
        {
            var parts = str.Split('|');

            _userAddr = int.Parse(parts[0], NumberStyles.HexNumber);
            _userKey = int.Parse(parts[1], NumberStyles.HexNumber);
            _userId = int.Parse(parts[2], NumberStyles.HexNumber);
        }

        /// <summary>
        /// Send last information without changes (only acknowledges frontend)
        /// </summary>
        public void Send(in uint cycle)
        {
            try
            {
                Debug.Assert(LastSentCycle < cycle);

                LastSentCycle = cycle;

                // if no actions were sent at this cycle, create a new block
                if (_actions.Count != 0 && _actions[^1].Cycle == 0)
                {
                    var block = _actions[^1];

                    block.Cycle = cycle;

                    // check last block isn't bigger than maximum allowed
                    int i;

                    // block size is 32 (cycle) + 8 (number of actions)
                    var bitSize = 32 + 8;

                    for (i = 0; i < block.Actions.Count; ++i)
                    {
                        bitSize += ActionFactory.Size(block.Actions[i]);

                        if (bitSize >= 480 * 8)
                            break;
                    }

                    if (i < block.Actions.Count)
                    {
                        // last block is bigger than allowed
                        _client.GetLogger().Debug($"Postponing {block.Actions.Count - i} actions exceeding max size in block {cycle} (block size is {bitSize} bits long)");

                        // allocate a new block
                        var newBlock = new ActionBlock();
                        _actions.Add(newBlock);

                        // reset block stamp
                        newBlock.Cycle = 0;

                        // copy remaining actions in new block
                        newBlock.Actions.AddRange(block.Actions.GetRange(i, block.Actions.Count - i));

                        // remove remaining actions of block
                        block.Actions.RemoveRange(i, block.Actions.Count - i);
                    }
                }

                if (ConnectionState == ConnectionState.Connected)
                {
                    SendNormalMessage();
                }
            }
            catch (Exception)
            {
                ConnectionState = ConnectionState.Disconnect;
                Disconnect();
            }
        }

        /// <summary>
        /// Create the message to send to the server
        /// </summary>
        private void SendNormalMessage()
        {
            var message = new BitMemoryStream();

            var systemMode = false;

            message.Serial(ref _currentSendNumber);
            message.Serial(ref systemMode);
            message.Serial(ref _lastReceivedNumber);
            message.Serial(ref _ackBitMask);

            for (int itblock = 0; itblock < _actions.Count; itblock++)
            {
                ActionBlock block = _actions[itblock];

                // if block contains action that are not already stamped, don't send it now
                if (block.Cycle == 0)
                    break;

                if (block.FirstPacket == 0)
                    block.FirstPacket = _currentSendNumber;

                block.Serial(message);

                //// for slow incoming streams instantly remove the action
                //_actions.RemoveAt(itblock);
                //itblock--;

                // Prevent to send a message too big - MTU 480? - easy version
                if (message.GetPosInBit() > 480 * 8)
                {
                    // TODO: i guess GetPosInBit does not return the right size - leads to disconnections
                    _client.GetLogger().Debug($"CNET: message size={message.GetPosInBit() / 8d:0}");

                    break;
                }
            }

            _client.GetLogger().Debug($"CNET: send normal message Packet={_currentSendNumber} Ack={_lastReceivedAck}");
            _client.GetLogger().Debug($"{message}");

            _connection.Send(message.Buffer(), message.Length);

            StatsSend(message.Length);

            _lastSendTime = Misc.GetLocalTime();

            // TODO _PacketStamps.push_back(make_pair(_CurrentSendNumber, _UpdateTime));

            _currentSendNumber++;
        }

        /// <summary>
        /// Send is temporised, that is the packet may not be actually sent.
        /// We don't care, since:
        /// - this packet has no new data (not ticked send)
        /// - a next send() will send packet if time elapsed enough
        /// - a next send(tick) will really be sent
        /// This way, we can say that at most 15 packets will be delivered each second
        /// (5 send(tick), and 10 send() -- if you take getLocalTime() inaccuracy into account)
        /// </summary>
        internal void Send()
        {
            try
            {
                if (ConnectionState == ConnectionState.Connected && Misc.GetLocalTime() - _lastSendTime > 100)
                {
                    SendNormalMessage();
                }
            }
            catch (Exception)
            {
                ConnectionState = ConnectionState.Disconnect;
            }
        }

        /// <summary>
        /// TODO updateSmoothServerTick - not that important for console client
        /// </summary>
        private void UpdateSmoothServerTick()
        {
        }

        /// <summary>
        /// Clear not acknownledged actions in sending buffer
        /// </summary>
        public void FlushSendBuffer()
        {
            _actions.Clear();
        }

        /// <summary>
        /// Buffers an action to be sent at next update (or later updates if network overload occurs)
        /// </summary>
        private void Push(ActionBase action)
        {
            if (_actions.Count == 0 || _actions[^1].Cycle != 0)
            {
                _actions.Add(new ActionBlock());
            }

            _actions[^1].Actions.Add(action);
        }

        /// <summary>
        /// Buffers a bitmemstream, that will be converted into a generic action, to be sent later to the server (at next update).
        /// </summary>
        public void Push(BitMemoryStream msg)
        {
            const int maxImpulseBitSize = 230 * 8;

            var ag = (ActionGeneric)ActionFactory.Create(Constants.InvalidSlot, ActionCode.ActionGenericCode);

            if (ag == null) //TODO: ryzom: see that with oliver...
                return;

            var bytelen = msg.Length;
            var impulseMinBitSize = ActionFactory.Size(ag);
            var impulseBitSize = impulseMinBitSize + (4 + bytelen) * 8;

            if (impulseBitSize < maxImpulseBitSize)
            {
                ag.Set(msg);
                Push(ag);
            }
            else
            {
                ActionBase casted = ag;
                ActionFactory.Remove(casted);

                // MultiPart impulsion
                var agmp = (ActionGenericMultiPart)ActionFactory.Create(Constants.InvalidSlot, ActionCode.ActionGenericMultiPartCode);
                var minimumBitSizeForMp = ActionFactory.Size(agmp);

                // (in bytes)
                var availableSize = (maxImpulseBitSize - minimumBitSizeForMp) / 8;

                var nbBlock = (bytelen + availableSize - 1) / availableSize;

                var num = _impulseMultiPartNumber++;

                for (var i = 0; i < nbBlock; i++)
                {
                    if (i != 0)
                    {
                        agmp = (ActionGenericMultiPart)ActionFactory.Create(Constants.InvalidSlot, ActionCode.ActionGenericMultiPartCode);
                    }

                    agmp.Set(num, (short)i, msg.Buffer(), bytelen, availableSize, (short)nbBlock);

                    Push(agmp);
                }
            }
        }

        /// <summary>
        /// Return the average billed upload rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        /// <param name="bytes"></param>
        private void StatsSend(int bytes)
        {
            _meanUpload.Update(bytes, Misc.GetLocalTime());
        }

        /// <summary>
        /// Return the average billed download rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        /// <param name="bytes"></param>
        private void StatsReceive(int bytes)
        {
            _meanDownload.Update(bytes, Misc.GetLocalTime());
        }

        /// <summary>
        /// Return the average billed download rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        public float GetMeanDownload()
        {
            return (_meanDownload.Mean(Misc.GetLocalTime()) + 20 + 8 + 14) * 0.008f;
        }

        /// <summary>
        /// Return the average billed upload rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        public float GetMeanUpload()
        {
            return (_meanUpload.Mean(Misc.GetLocalTime()) + 20 + 8 + 14) * 0.008f;
        }

        /// <summary>
        /// Return the packet loss average
        /// </summary>
        public float GetMeanPacketLoss()
        {
            var time = Misc.GetLocalTime();
            _meanPackets.Check(time);
            _meanLoss.Check(time);
            var dpk = _meanPackets.Dpk();
            var tloss = _meanLoss.Content;
            return dpk > 0.0f ? Math.Min(100.0f, tloss * 100.0f / dpk) : 0.0f;
        }

        /// <summary>
        /// Retrieve the averaged ping value
        /// </summary>
        public int GetPing()
        {
            return (int)Math.Round(_ping.Average());
        }

        /// <summary>
        /// Set player's reference position
        /// </summary>
        public void SetReferencePosition(Vector3 position)
        {
            _propertyDecoder.SetReferencePosition(position);
        }

        public void DecodeDiscreteProperty(BitMemoryStream msgin, byte propIndex)
        {
            //if (propIndex == 6)
            //_client.GetLogger().Info($"Reading discrete property {propIndex} ({(PropertyType)propIndex}) at bitpos {msgin.GetPosInBit()} remaining {msgin.Length * 8 - msgin.GetPosInBit()}");

            PropertyChange propertyChange;
            var slot = VisualPropertyNodeClient.SlotContext.Slot;

            // todo: BEN this is temp, put it somewhere in database
            if (propIndex == (byte)PropertyType.TargetList)
            {
                byte listSize = 0;
                msgin.Serial(ref listSize);

                if (listSize > 0)
                {
                    var values = new byte[listSize];
                    msgin.Serial(ref values);
                    _targetSlotsList = new List<byte>(values);
                }

                // Set target list value in database
                if (_databaseManager != null)
                {
                    if (_databaseManager.GetNodePtr().GetNode(0) is DatabaseNodeBranch nodeRoot)
                    {
                        var nodeEntity = nodeRoot.GetNode(slot) as DatabaseNodeBranch;
                        Debug.Assert(nodeEntity != null);

                        ushort writeProp = (byte)PropertyType.TargetList;
                        var place = 0;

                        if (listSize >= 32)
                        {
                            listSize = 32;
                        }
                        else
                        {
                            _targetSlotsList.Add(Constants.InvalidSlot);
                            ++listSize;
                        }

                        DatabaseNodeLeaf nodeProp;

                        int i;
                        long value = 0;

                        for (i = 0; i < listSize; ++i)
                        {
                            if (place == 0)
                            {
                                value = 0;
                            }

                            value += (long)_targetSlotsList[i] << (place * 8);

                            ++place;

                            if (place == 8)
                            {
                                nodeProp = nodeEntity.GetNode(writeProp) as DatabaseNodeLeaf;
                                Debug.Assert(nodeProp != null);
                                nodeProp.SetValue64(value);
                                ++writeProp;
                                place = 0;
                            }
                        }

                        if (place != 0)
                        {
                            nodeProp = nodeEntity.GetNode(writeProp) as DatabaseNodeLeaf;
                            Debug.Assert(nodeProp != null);
                            nodeProp.SetValue64(value);
                        }
                    }

                    _client.GetLogger().Debug($"CLIENT: recvd property {(ushort)propIndex}u ({propIndex}) for slot {(ushort)slot}u, date {VisualPropertyNodeClient.SlotContext.Timestamp}");
                }

                propertyChange = new PropertyChange(slot, propIndex, VisualPropertyNodeClient.SlotContext.Timestamp);
                _changes.Add(propertyChange);

                return;
            }

            var ac = (ActionLong)ActionFactory.CreateByPropIndex(slot, propIndex);
            ac.Unpack(msgin);

            switch (propIndex)
            {
                case (byte)PropertyType.Sheet:
                    // Special case for sheet
                    if (_propertyDecoder.IsUsed(slot))
                    {
                        var sheet = _propertyDecoder.Sheet(slot);

                        if (_idMap.ContainsKey(sheet)) { _idMap.Remove(sheet); }

                        _propertyDecoder.RemoveEntity(slot);
                    }

                    var newSheetId = (uint)(ac.GetValue() & 0xffffffff);
                    if (_idMap.ContainsKey(newSheetId)) _idMap.Remove(newSheetId);
                    _idMap.Add(newSheetId, slot);

                    _propertyDecoder.AddEntity(slot, newSheetId);

                    // TODO: Reset the position update statistical data
                    //_posUpdateTicks[slot].clear();
                    //_posUpdateIntervals[slot].clear();

                    // Read optional alias block
                    uint alias = 0;
                    var aliasBit = false;
                    msgin.Serial(ref aliasBit);

                    if (aliasBit)
                    {
                        msgin.Serial(ref alias);
                    }

                    // Set information
                    propertyChange = new PropertyChange(slot, (byte)PropertyType.AddNewEntity);
                    propertyChange.NewEntityInfo.DataSetIndex = (uint)((ac.GetValue() >> 32) & 0xffffffff);
                    propertyChange.NewEntityInfo.Alias = alias;
                    _changes.Add(propertyChange);

                    break;

                case (byte)PropertyType.Mode:
                    // Special case for mode: push theta or pos, then mode
                    var mode44 = ac.GetValue();
                    var modeTimestamp = _currentServerTick - (uint)((mode44 >> 8) & 0xF);

                    // Push the mode Before the position or the orientation
                    propertyChange = new PropertyChange(slot, (byte)PropertyType.Mode, modeTimestamp);
                    _changes.Add(propertyChange);

                    // Set mode value in database
                    if (_databaseManager != null)
                    {
                        if (_databaseManager.GetNodePtr().GetNode(0) is DatabaseNodeBranch nodeRoot)
                        {
                            var node = nodeRoot.GetNode(slot).GetNode(propIndex) as DatabaseNodeLeaf;
                            Debug.Assert(node != null);
                            node.SetValue64(ac.GetValue() & 0xFF); // (8 bits)
                        }
                    }

                    // Set the position or orientation received along with the mode in the database
                    byte modeEnum = (byte)(mode44 & 0xFF);
                    const int combatFloat = 2;

                    if (modeEnum == combatFloat)
                    {
                        // Set theta
                        if (_databaseManager != null)
                        {
                            if (_databaseManager.GetNodePtr().GetNode(0) is DatabaseNodeBranch nodeRoot)
                            {
                                var node = nodeRoot.GetNode(slot).GetNode((byte)PropertyType.Orientation) as DatabaseNodeLeaf;
                                Debug.Assert(node != null);
                                node.SetValue64(mode44 >> 12);
                            }
                        }
                    }
                    else
                    {
                        // Set 2D position (the position at TVPNodeClient::SlotContext.Timestamp is not sent at the same time as the position for Mode)
                        if (_databaseManager != null)
                        {
                            var x16 = (ushort)((ac.GetValue() >> 12) & 0xFFFF);
                            var y16 = (ushort)((ac.GetValue() >> 28) & 0xFFFF);

                            if (!(x16 == 0 && y16 == 0)) // don't set the position if it was not initialized yet
                            {
                                var x = new int();
                                var y = new int();

                                _propertyDecoder.DecodeAbsPos2D(ref x, ref y, x16, y16);

                                if (_databaseManager.GetNodePtr().GetNode(0) is DatabaseNodeBranch nodeRoot)
                                {
                                    var node = nodeRoot.GetNode(slot).GetNode(0) as DatabaseNodeLeaf;
                                    Debug.Assert(node != null);
                                    node.SetValue64(x);
                                    node = nodeRoot.GetNode(slot).GetNode(1) as DatabaseNodeLeaf;
                                    Debug.Assert(node != null);
                                    node.SetValue64(y);
                                }
                            }
                            else
                            {
                                // TODO: fix Received mode with null pos
                                RyzomClient.GetInstance().GetLogger().Debug($"{_currentServerTick}: S{(ushort)slot}u: Received mode with null pos"); // TEMP
                            }
                        }
                    }

                    break;

                default:
                    // special for Bars, always take _currentServerTick timestamp (delta timestamp decoded is mainly for position purpose...)
                    var timeStamp = VisualPropertyNodeClient.SlotContext.Timestamp;
                    /* YOYO: i don't know what to do with others property that really use the gamecycle and are maybe buggued:
                        ENTITY_MOUNTED_ID,RIDER_ENTITY_ID,BEHAVIOUR,TARGET_LIST,TARGET_ID,VISUAL_FX
                        But bars timestamp accuracy is very important (else could take DB property with falsly newer timestamp)
                    */
                    if (propIndex == (byte)PropertyType.Bars)
                    {
                        timeStamp = _currentServerTick;
                    }

                    // Process property
                    propertyChange = new PropertyChange(slot, propIndex, timeStamp);
                    _changes.Add(propertyChange);

                    if (_databaseManager != null)
                    {
                        if (_databaseManager.GetNodePtr().GetNode(0) is DatabaseNodeBranch nodeRoot)
                        {
                            var node = nodeRoot.GetNode(slot).GetNode(propIndex) as DatabaseNodeLeaf;
                            Debug.Assert(node != null);
                            node.SetValue64(ac.GetValue());
                        }
                    }

                    break;
            }

            ActionFactory.Remove(ac);
        }

        /// <summary>
        ///  Buffers a target action (set targetOrPickup to true for target, false for pick-up)
        /// </summary>
        public void PushTarget(byte slot, TargettingType targetOrPickup)
        {
            var ats = (ActionTargetSlot)ActionFactory.Create(Constants.InvalidSlot, ActionCode.ActionTargetSlotCode);

            Debug.Assert(ats != null);
            ats.Slot = slot;

            //// ensure the value is good for the FE
            //switch (targetOrPickup)
            //{
            //    case TargettingType.None:
            //        ats.TargetOrPickup = 0;
            //        break;
            //
            //    case TargettingType.Lootable:
            //        ats.TargetOrPickup = 1;
            //        break;
            //
            //    case TargettingType.Harvestable:
            //        ats.TargetOrPickup = 2;
            //        break;
            //
            //    default:
            //        return;
            //}

            ats.TargetOrPickup = (uint)targetOrPickup;

            Push(ats);
        }
    }

    internal class NetworkLoginException : Exception
    {
        public NetworkLoginException(string message) : base(message) { }
    }
}