///////////////////////////////////////////////////////////////////
// This file contains modified code from 'Ryzom - MMORPG Framework'
// http://dev.ryzom.com/projects/ryzom/
// which is released under GNU Affero General Public License.
// http://www.gnu.org/licenses/
// Copyright 2010 Winch Gate Property Limited
///////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Threading;
using RCC.Config;
using RCC.Database;
using RCC.Entity;
using RCC.Helper;
using RCC.Network.Action;

namespace RCC.Network
{
    /// <summary>
    /// Abstracts the connection client towards front-end
    /// handles incoming and outgoing messages from the game server and keeps track of the current state of the connection 
    /// </summary>
    public class NetworkConnection
    {
        public uint LastSentCycle;

        /// <summary>
        /// method used for incoming impulses
        /// </summary>
        internal Action<BitMemoryStream> ImpulseCallback;

        /// <summary>
        /// The UDP connection to the frontend
        /// </summary>
        private readonly UdpSocket _connection = new UdpSocket();

        /// <summary>
        /// The current state of the connection
        /// </summary>
        private ConnectionState _connectionState = ConnectionState.NotInitialized;

        /// <summary>
        /// Generic action multipart handling structures
        /// </summary>
        private readonly List<GenericMultiPartTemp> _genericMultiPartTemp = new List<GenericMultiPartTemp>();

        /// <summary>
        /// actions in sending buffer
        /// </summary>
        private readonly List<ActionBlock> _actions = new List<ActionBlock>();

        /// <summary>
        /// Changes since
        /// </summary>
        private readonly List<Change> _changes = new List<Change>();

        #region Login Variables
        /// <summary>
        /// is the ipv4 address of the client in uint32
        /// </summary>
        private int _userAddr;

        /// <summary>
        /// is an uint32 generated by the login_service at each login password verification
        /// </summary>
        private int _userKey;

        /// <summary>
        /// is an uint32 uniq for each account (an account could have more than one avatar)
        /// </summary>
        private int _userId;

        /// <summary>
        /// The address of the frontend service
        /// </summary>
        private string _frontendAddress;

        private int _loginAttempts;
        #endregion

        /// <summary>
        /// number that will be used to send the next packet
        /// </summary>
        private int _currentSendNumber;
        /// <summary>
        /// number of the last packet receive from the server
        /// </summary>
        private int _lastReceivedNumber;
        /// <summary>
        /// this mask contains ack of old messages received by the server
        /// </summary>
        private uint _ackBitMask;
        /// <summary>
        /// a remember of the status of the previous received packet
        /// </summary>
        private uint _lastAckBit;

        private uint _synchronize;

        private int _lastAckInLongAck;

        private long _latestLoginTime;
        private uint _latestSync;
        private long _latestSyncTime;
        private long _latestProbeTime;
        private long _updateTime;
        private long _lastSendTime;

        private int _totalMessages;

        VpNodeClient _VisualPropertyTreeRoot;

        /// <summary>
        /// the time currently played at this frame (in the past)
        /// </summary>
        private long _currentClientTime;
        /// <summary>
        /// the tick for the current frame (in the past)
        /// </summary>
        private uint _currentClientTick;
        /// <summary>
        /// the last tick sent by the server
        /// </summary>
        private uint _currentServerTick;
        /// <summary>
        /// Lag Compensation Time in ms (default: 1000)
        /// </summary>
        private int _lct;

        /// <summary>
        /// Was the header decoded for the last received message?
        /// </summary>
        private bool _decodedHeader;
        /// <summary>
        /// The message is in system mode
        /// </summary>
        private bool _systemMode;
        /// <summary>
        /// The received number lastly decoded
        /// </summary>
        private int _currentReceivedNumber;
        private int _lastReceivedAck;
        private int _msPerTick;

        private bool _registered;
        private readonly List<int> _latestProbes = new List<int>();
        private int _latestProbe;

        private const int NumBitsInLongAck = 512;
        private bool[] _longAckBitField = new bool[NumBitsInLongAck * 2];

        /// <summary>
        /// MD5 hash keys of msg.xml
        /// </summary>
        private byte[] _msgXmlMD5;

        /// <summary>
        /// MD5 hash keys of database.xml
        /// </summary>
        private byte[] _databaseXmlMD5;

        private bool _alreadyWarned;

        private long _previousTime;

        /// <summary>
        /// /// Mean download (payload bytes)
        /// </summary>
        private readonly MeanComputer _meanDownload = new MeanComputer();

        /// <summary>
        /// /// Mean upload (payload bytes)
        /// </summary>
        private readonly MeanComputer _meanUpload = new MeanComputer();

        /// <summary>
        /// /// Mean packets
        /// </summary>
        private readonly MeanComputer _meanPackets = new MeanComputer(5000);

        /// <summary>
        /// Mean lost
        /// </summary>
        private readonly MeanComputer _meanLoss = new MeanComputer(5000);

        /// <summary>
        /// Main client reference
        /// </summary>
        private readonly RyzomClient _client;

        /// <summary>
        /// Ingame Database Manager
        /// </summary>
        private readonly CDBSynchronised _databaseManager;

        /// <summary>
        /// the last tick sent by the server
        /// </summary>
        public uint GetCurrentServerTick() => _currentServerTick;

        /// <summary>
        /// Gets the connection state
        /// </summary>
        public ConnectionState ConnectionState
        {
            get => _connectionState;
            set
            {
                _client.GetLogger().Info($"Connection state changed to {value}");
                _connectionState = value;
            }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public NetworkConnection(RyzomClient client, CDBSynchronised databaseManager)
        {
            _connectionState = ConnectionState.NotInitialized;

            _client = client;
            _databaseManager = databaseManager;

            Reset();

            InitTicks();
        }

        /// <summary>
        /// Init the connection with the cookie from the login server and game server address - registers all action codes
        /// </summary>
        /// <param name="cookie">cookie it s the cookie in string format that was passed to the exe command line (given by the nel_launcher)</param>
        /// <param name="addr">addr it s the front end address in string format that was passed to the exe command line (given by the nel_launcher)</param>
        public void Init(string cookie, string addr)
        {
            if (ConnectionState != ConnectionState.NotInitialized &&
                ConnectionState != ConnectionState.Disconnect)
            {
                throw new Exception("Unable to init(): connection not properly closed yet.");
            }

            if (!_registered)
            {
                ActionFactory.RegisterAction(ActionCode.ActionGenericCode, typeof(ActionGeneric));
                ActionFactory.RegisterAction(ActionCode.ActionGenericMultiPartCode, typeof(ActionGenericMultiPart));

                _registered = true;
            }

            InitCookie(cookie, addr);

            // Init visual property tree
            _VisualPropertyTreeRoot = new VpNodeClient();
            _VisualPropertyTreeRoot.BuildTree();

            // get md5 hashes
            _msgXmlMD5 = Misc.GetFileMD5("data\\msg.xml");
            _databaseXmlMD5 = Misc.GetFileMD5("data\\database.xml");
        }

        /// <summary>
        /// Sets the cookie and front-end address, resets the connection state.
        /// </summary>
        public void InitCookie(string cookie, string addr)
        {
            _frontendAddress = addr;

            SetLoginCookieFromString(cookie);

            _client.GetLogger().Info($"Network initialization with front end '{_frontendAddress}'");
            _client.GetLogger().Debug($"cookie {cookie}");

            ConnectionState = ConnectionState.NotConnected;
        }

        /// <summary>
        /// Reset of the packet data counters and times
        /// </summary>
        public void Reset()
        {
            _currentSendNumber = 0;
            _lastReceivedNumber = 0;
            _ackBitMask = 0;
            _lastAckBit = 0;

            _synchronize = 0;
            _lct = 100;

            _latestSync = 0;

            _longAckBitField = new bool[NumBitsInLongAck * 2];

            _lastAckInLongAck = 0;
            LastSentCycle = 0;

            _meanPackets.MeanPeriod = 5000;
            _meanLoss.MeanPeriod = 5000;
        }

        private void InitTicks()
        {
            _msPerTick = 100;
        }

        /// <summary>
        /// Connects to the front-end (using or not the login system, depending on what was specified at init())
        /// Start the connection state machine - Udp socket will connect at this point
        /// </summary>
        internal void Connect()
        {
            if (ConnectionState != ConnectionState.NotConnected)
            {
                throw new Exception(
                    "Unable to connect(): connection not properly initialized (maybe connection not closed).");
            }

            // S12: connect to the FES. Note: In UDP mode, it's the user that have to send the cookie to the front end
            try
            {
                _connection.Connect(_frontendAddress);
            }
            catch (Exception e)
            {
                throw new Exception("FS refused the connection (" + e.Message + ")");
            }

            ConnectionState = ConnectionState.Login;

            _latestLoginTime = Misc.GetLocalTime();
            _latestSyncTime = _latestLoginTime;
            _latestProbeTime = _latestLoginTime;
            _loginAttempts = 0;
        }

        /// <summary>
        /// Sets the callback called when a generic impulse comes
        /// </summary>
        public void SetImpulseCallback(Action<BitMemoryStream> impulseCallBack)
        {
            ImpulseCallback = impulseCallBack;
        }

        /// <summary>
        /// Updates the whole connection with the frontend.
        ///
        /// Behaviour in login state when a firewall does not grant the sending:
        /// - When a sending is refused (error "Blocking operation interrupted")
        /// the exception EBlockedByFirewall in thrown. The first time, a time-out is armed.
        /// - In a later attempt, if the time-out expired, the function sets state to
        /// Disconnect, then throws EBlockedByFirewall.
        ///
        /// tests the connection state and inits the state machine
        /// </summary>
        /// <returns>bool 'true' if data were sent/received.</returns>
        public bool Update()
        {
            _updateTime = Misc.GetLocalTime();
            _totalMessages = 0;

            // If we are disconnected, bypass the real network update
            if (ConnectionState == ConnectionState.Disconnect)
            {
                return false;
            }

            // Yoyo. OnUpdate the Smooth ServerTick.
            UpdateSmoothServerTick();

            if (!_connection.Connected())
            {
                _client.GetLogger().Warn("CNET: update() attempted whereas socket is not connected !");
                return false;
            }

            try
            {
                // State automaton
                bool stateBroke;

                do
                {
                    stateBroke = ConnectionState switch
                    {
                        ConnectionState.Login =>
                            // if receives System SYNC
                            //    immediate state Synchronize
                            // else
                            //    sends System LoginCookie
                            StateLogin(),
                        ConnectionState.Synchronize =>
                            // if receives System PROBE
                            //    immediate state Probe
                            // else if receives Normal
                            //    immediate state Connected
                            // else
                            //    sends System ACK_SYNC
                            StateSynchronize(),
                        ConnectionState.Connected =>
                            // if receives System PROBE
                            //    immediate state Probe
                            // else if receives Normal
                            //	   sends Normal data
                            StateConnected(),
                        ConnectionState.Probe =>
                            // if receives System SYNC
                            //    immediate state SYNC
                            // else if receives System PROBE
                            //    decode PROBE
                            // sends System ACK_PROBE
                            StateProbe(),
                        ConnectionState.Stalled =>
                            // if receives System SYNC
                            //    immediate state SYNC
                            // else if receives System STALLED
                            //    decode STALLED (nothing to do)
                            // else if receives System PROBE
                            //    immediate state PROBE
                            StateStalled(),
                        ConnectionState.Quit =>
                            // if receives System SYNC
                            //    immediate state Synchronize
                            // else
                            //    sends System LoginCookie
                            StateQuit(),
                        _ => false
                    };
                } while (stateBroke); // && _TotalMessages<5);
            }
            catch (Exception)
            {
                _connectionState = ConnectionState.Disconnect;
            }

            return _totalMessages != 0;
        }

        /// <summary>
        ///     Connection state machine - Login state
        ///     if receives System SYNC
        ///     immediate state Synchronize
        ///     else
        ///     sends System LoginCookie
        /// </summary>
        private bool StateLogin()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync
                                ConnectionState = ConnectionState.Synchronize;
                                _client.GetLogger().Debug("CNET: login->synchronize");
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Stalled;
                                _client.GetLogger().Debug("CNET: login->stalled");
                                ReceiveSystemStalled(msgin);
                                return true;

                            case SystemMessageType.SystemProbeCode:
                                // receive probe, decode probe and state probe
                                ConnectionState = ConnectionState.Probe;
                                _changes.Add(new Change(0, (byte)Change.Prop.ProbeReceived));
                                _client.GetLogger().Debug("CNET: login->probe");
                                ReceiveSystemProbe(msgin);
                                return true;

                            case SystemMessageType.SystemServerDownCode:
                                Disconnect(); // will send disconnection message
                                _client.GetLogger().Error("BACK-END DOWN");
                                return false; // exit now from loop, don't expect a new state

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Login");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET: received normal in state Login");
                    }
                }
            }


            // send ack sync if received sync or last sync timed out
            if (_updateTime - _latestLoginTime > 300)
            {
                SendSystemLogin();
                _latestLoginTime = _updateTime;

                if (_loginAttempts > 24)
                {
                    _loginAttempts = 0;
                    // will send disconnection message
                    Disconnect();
                    _client.GetLogger().Warn("CNET: Too many LOGIN attempts, connection problem");
                    // exit now from loop, don't expect a new state
                    return true;
                }

                ++_loginAttempts;
            }

            return false;
        }

        /// <summary>
        ///     Connection state machine - Probe State
        ///     if receives System SYNC
        ///     immediate state SYNC
        ///     else if receives System PROBE
        ///     decode PROBE
        ///     sends System ACK_PROBE
        /// </summary>
        private bool StateProbe()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync and state synchronize
                                ConnectionState = ConnectionState.Synchronize;
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive sync, decode sync and state synchronize
                                ConnectionState = ConnectionState.Stalled;
                                ReceiveSystemStalled(msgin);
                                return true;

                            case SystemMessageType.SystemProbeCode:
                                // receive sync, decode sync
                                ReceiveSystemProbe(msgin);
                                break;

                            case SystemMessageType.SystemServerDownCode:
                                // will send disconnection message
                                Disconnect();
                                _client.GetLogger().Error("BACK-END DOWN");
                                // exit now from loop, don't expect a new state
                                return false;

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Probe");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET: received normal in state Probe");
                        _latestProbeTime = _updateTime;
                    }
                }
            }

            // send ack sync if received sync or last sync timed out
            if (_latestProbes.Count != 0 || _updateTime - _latestProbeTime > 300)
            {
                SendSystemAckProbe();
                _latestProbeTime = _updateTime;
            }
            else
                Thread.Sleep(10);

            return false;
        }

        /// <summary>
        ///     Connection state machine - Synchronize State
        ///     if receives System PROBE
        ///     immediate state Probe
        ///     else if receives Normal
        ///     immediate state Connected
        ///     sends System ACK_SYNC
        /// </summary>
        private bool StateSynchronize()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemProbeCode:
                                // receive probe, decode probe and state probe
                                ConnectionState = ConnectionState.Probe;
                                _changes.Add(new Change(0, (byte)Change.Prop.ProbeReceived));
                                ReceiveSystemProbe(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Stalled;
                                ReceiveSystemStalled(msgin);
                                return true;

                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync
                                ReceiveSystemSync(msgin);
                                break;

                            case SystemMessageType.SystemServerDownCode:
                                // will send disconnection message
                                Disconnect();
                                _client.GetLogger().Error("BACK-END DOWN");
                                // exit now from loop, don't expect a new state
                                return false;

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Synchronize");
                                break;
                        }
                    }
                    else
                    {
                        ConnectionState = ConnectionState.Connected;

                        _changes.Add(new Change(0, (byte)Change.Prop.ConnectionReady));

                        ImpulseDecoder.Reset();

                        ReceiveNormalMessage(msgin);

                        return true;
                    }
                }
            }

            // send ack sync if received sync or last sync timed out
            if (_updateTime - _latestSyncTime > 300)
                SendSystemAckSync();

            return false;
        }

        /// <summary>
        ///     Connection state machine - Connected State
        ///     if receives System PROBE
        ///     immediate state Probe
        ///     else if receives Normal
        ///     sends Normal data
        /// </summary>
        private bool StateConnected()
        {
            // Prevent to increment the client time when the front-end does not respond
            var now = Misc.GetLocalTime();
            var diff = now - _previousTime;
            _previousTime = Misc.GetLocalTime();

            if (diff > 3000 && !_connection.IsDataAvailable())
            {
                return false;
            }

            // update the current time;
            while (_currentClientTime < _updateTime - _msPerTick - _lct &&
                   _currentClientTick < _currentServerTick)
            {
                _currentClientTime += _msPerTick;

                _currentClientTick++;
            }

            if (_currentClientTick >= _currentServerTick && !_connection.IsDataAvailable())
            {
                return false;
            }

            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemProbeCode:
                                // receive probe, and goto state probe
                                ConnectionState = ConnectionState.Probe;

                                _changes.Add(new Change(0, (byte)Change.Prop.ProbeReceived));
                                ReceiveSystemProbe(msgin);
                                return true;

                            case SystemMessageType.SystemSyncCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Synchronize;
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled and state stalled
                                ConnectionState = ConnectionState.Stalled;
                                ReceiveSystemStalled(msgin);
                                return true;

                            case SystemMessageType.SystemServerDownCode:
                                // will send disconnection message
                                Disconnect();
                                _client.GetLogger().Error("BACK-END DOWN");
                                // exit now from loop, don't expect a new state
                                return false;

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Connected");
                                break;
                        }
                    }
                    else
                    {
                        ReceiveNormalMessage(msgin);
                    }
                }
            }

            return false;
        }


        /// <summary>
        ///     Connection state machine - Stalled State
        /// if receives System SYNC
        ///    immediate state SYNC
        /// else if receives System STALLED
        ///    decode STALLED (nothing to do)
        /// else if receives System PROBE
        ///    immediate state PROBE
        /// </summary>
        private bool StateStalled()
        {
            while (_connection.IsDataAvailable())
            {
                _decodedHeader = false;
                var msgin = new BitMemoryStream(true);

                if (BuildStream(msgin) && DecodeHeader(msgin))
                {
                    if (_systemMode)
                    {
                        byte message = 0;
                        msgin.Serial(ref message);

                        switch ((SystemMessageType)message)
                        {
                            case SystemMessageType.SystemSyncCode:
                                // receive sync, decode sync and state synchronize
                                _connectionState = ConnectionState.Synchronize;
                                _client.GetLogger().Debug("CNET: stalled->synchronize");
                                ReceiveSystemSync(msgin);
                                return true;

                            case SystemMessageType.SystemProbeCode:
                                // receive sync, decode sync
                                _connectionState = ConnectionState.Probe;
                                _client.GetLogger().Debug("CNET: stalled->probe");
                                ReceiveSystemProbe(msgin);
                                break;

                            case SystemMessageType.SystemStalledCode:
                                // receive stalled, decode stalled
                                ReceiveSystemStalled(msgin);
                                break;

                            case SystemMessageType.SystemServerDownCode:
                                Disconnect(); // will send disconnection message
                                _client.GetLogger().Error("BACK-END DOWN");
                                return false; // exit now from loop, don't expect a new state

                            default:
                                _client.GetLogger().Warn($"CNET: received system {message} in state Stalled");
                                break;
                        }
                    }
                    else
                    {
                        _client.GetLogger().Warn("CNET: received normal in state Stalled");
                    }
                }
            }

            return false;
        }

        /// <summary>
        ///     Connection state machine - Quit State
        ///     TODO: Connection state machine - Quit State
        /// </summary>
        private bool StateQuit()
        {
            _client.GetLogger().Error($"{MethodBase.GetCurrentMethod()?.Name} called, but not implemented");
            Disconnect();
            return false;
        }

        /// <summary>
        ///     Receive and extract a normal (non system) message from a stream
        /// </summary>
        private void ReceiveNormalMessage(BitMemoryStream msgin)
        {
            _client.GetLogger().Debug($"CNET: received normal message Packet={_lastReceivedNumber} Ack={_lastReceivedAck}");
            _client.GetLogger().Debug($"{msgin}");

            var actions = new List<ActionBase>();
            ImpulseDecoder.Decode(msgin, _currentReceivedNumber, _lastReceivedAck, _currentSendNumber, actions);

            // we can now remove all old action that are acked
            while (_actions.Count != 0 && _actions[0].FirstPacket != 0 && _actions[0].FirstPacket <= _lastReceivedAck)
            {
                // CActionBlock automatically remove() actions when deleted
                _client.GetLogger().Debug($"removed action {_actions[0]}");
                _actions.RemoveAt(0);
            }

            Debug.Assert(_currentReceivedNumber * 2 + _synchronize > _currentServerTick);
            _currentServerTick = (uint)(_currentReceivedNumber * 2 + _synchronize);

            // TODO: receiveNormalMessage PacketStamps implementation

            // Decode the actions received in the impulsions
            foreach (var action in actions)
            {
                switch (action.Code)
                {
                    case ActionCode.ActionDisconnectionCode:
                        // Self disconnection
                        _client.GetLogger().Info("You were disconnected by the server");
                        // will send disconnection message
                        Disconnect();
                        break;

                    case ActionCode.ActionGenericCode:
                        GenericAction((ActionGeneric)action);
                        break;

                    case ActionCode.ActionGenericMultiPartCode:
                        GenericAction((ActionGenericMultiPart)action);
                        break;

                    case ActionCode.ActionDummyCode:
                        _client.GetLogger().Debug($"CNET Received Dummy {action}");
                        // Nothing to do
                        break;
                }

                ActionFactory.Remove(action);
            }

            // Decode the visual properties
            DecodeVisualProperties(msgin);
        }

        /// <summary>
        ///     extract properties (database, sheets, ...) from a stream
        /// </summary>
        private void DecodeVisualProperties(BitMemoryStream msgin)
        {
            try
            {
                //nldebug( "pos: %d  len: %u", msgin.getPos(), msgin.length() );
                while (true)
                {
                    //nlinfo( "Reading pass %u, BEFORE HEADER: pos: %d  len: %u", ++i, msgin.getPosInBit(), msgin.length() * 8 );

                    // Check if there is a new block to read
                    if (msgin.GetPosInBit() + (sizeof(byte) * 8) > msgin.Length * 8)
                        return;

                    // Header
                    byte slot = 0;
                    msgin.Serial(ref slot);

                    uint associationBits = 0;
                    msgin.Serial(ref associationBits, 2);

                    //_client.Log.Info($"slot {slot} AB: {associationBits}");

                    //        if (associationBitsHaveChanged(slot, associationBits) && (!IgnoreEntityDbUpdates || slot == 0))
                    //        {
                    //            //displayBitStream( msgin, beginbitpos, msgin.getPosInBit() );
                    //            //			   nlinfo ("Disassociating S%hu (AB %u)", (uint16)slot, associationBits );
                    //            if (_PropertyDecoder.isUsed(slot))
                    //            {
                    //                TSheetId sheet = _PropertyDecoder.sheet(slot);
                    //                TIdMap::iterator it = _IdMap.find(sheet);
                    //                if (it != _IdMap.end())
                    //                    _IdMap.erase(it);
                    //                _PropertyDecoder.removeEntity(slot);
                    //
                    //                CChange theChange(slot, RemoveOldEntity );
                    //                _Changes.push_back(theChange);
                    //            }
                    //            else
                    //            {
                    //					nlinfo( "Cannot disassociate slot %hu: sheet not received yet", (uint16)slot );
                    //            }
                    //        }
                    //

                    // Read the timestamp delta if there's one (otherwise take _CurrentServerTick)
                    uint timestamp;
                    bool timestampIsThere = false;
                    msgin.Serial(ref timestampIsThere);

                    if (timestampIsThere)
                    {
                        uint timestampDelta = 0;
                        msgin.Serial(ref timestampDelta, 4);
                        timestamp = _currentServerTick - timestampDelta;
                        //nldebug( "TD: %u (S%hu)", timestampDelta, (uint16)slot );
                    }
                    else
                    {
                        timestamp = _currentServerTick;
                    }

                    //_client.Log.Info($"slot {slot} AB: {associationBits} timestamp: {timestamp}");

                    // Tree
                    //nlinfo( "AFTER HEADER: posBit: %d pos: %d  len: %u", msgin.getPosInBit(), msgin.getPos(), msgin.length() );

                    VpNodeClient currentNode = _VisualPropertyTreeRoot;
                    msgin.Serial(ref currentNode.A().BranchHasPayload);

                    if (currentNode.A().BranchHasPayload)
                    {
                        //            CActionPosition* ap = (CActionPosition*)CActionFactory::getInstance()->create(slot, ACTION_POSITION_CODE);
                        //            ap->unpack(msgin);
                        //            _PropertyDecoder.receive(_CurrentReceivedNumber, ap);
                        //
                        //            /*
                        //             * Set into property database
                        //             */
                        //
                        //            // TEMP
                        //            if (ap->Position[0] == 0 || ap->Position[1] == 0)
                        //                nlwarning("S%hu: Receiving an invalid position", (uint16)slot);
                        //
                        //            if (_DataBase != NULL && (!IgnoreEntityDbUpdates || slot == 0))
                        //            {
                        //                CCDBNodeBranch* nodeRoot;
                        //                nodeRoot = dynamic_cast<CCDBNodeBranch*>(_DataBase->getNode((uint16)0));
                        //                if (nodeRoot)
                        //                {
                        //                    CCDBNodeLeaf* node;
                        //                    node = dynamic_cast<CCDBNodeLeaf*>(nodeRoot->getNode(slot)->getNode(0));
                        //                    nlassert(node != NULL);
                        //                    node->setValue64(ap->Position[0]);
                        //                    node = dynamic_cast<CCDBNodeLeaf*>(nodeRoot->getNode(slot)->getNode(1));
                        //                    nlassert(node != NULL);
                        //                    node->setValue64(ap->Position[1]);
                        //                    node = dynamic_cast<CCDBNodeLeaf*>(nodeRoot->getNode(slot)->getNode(2));
                        //                    nlassert(node != NULL);
                        //                    node->setValue64(ap->Position[2]);
                        //
                        //                    if (LoggingMode)
                        //                    {
                        //                        nlinfo("recvd position (%d,%d) for slot %hu, date %u", (sint32)(ap->Position[0]), (sint32)(ap->Position[1]), (uint16)slot, timestamp);
                        //                    }
                        //                }
                        //            }
                        //
                        //            bool interior = ap->Interior;
                        //
                        //            CActionFactory::getInstance()->remove((CAction * &)ap);
                        //
                        //
                        //            /*
                        //             * Statistical prediction of time before next position update: set PredictedInterval
                        //             */
                        //
                        //            //nlassert( MAX_POSUPDATETICKQUEUE_SIZE > 1 );
                        //            deque<TGameCycle> & puTicks = _PosUpdateTicks[slot];
                        //            multiset<TGameCycle> & puIntervals = _PosUpdateIntervals[slot];
                        //
                        //            // Flush the old element of tick queue and of the interval sorted set
                        //            if (puTicks.size() == MAX_POSUPDATETICKQUEUE_SIZE)
                        //            {
                        //                puIntervals.erase(puIntervals.find(puTicks[1] - puTicks[0])); // erase only one element, not all corresponding to the value
                        //                puTicks.pop_front();
                        //            }
                        //
                        //            // Add a new element to the tick queue and possibly to the interval sorted set
                        //            // Still to choose: _CurrentServerTick or timestamp ?
                        //            TGameCycle latestInterval = 0;
                        //            if (!puTicks.empty())
                        //            {
                        //                latestInterval = timestamp - puTicks.back();
                        //                puIntervals.insert(latestInterval);
                        //
                        //                if (PosUpdateIntervalGraph)
                        //                    PosUpdateIntervalGraph->addOneValue(slot, (float)latestInterval);
                        //            }
                        //            puTicks.push_back(timestamp);
                        //
                        //            nlassert(puTicks.size() == puIntervals.size() + 1);
                        //
                        //            // Prediction function : Percentile(25 last, 0.8) + 1
                        //            TGameCycle predictedInterval;
                        //            if (puIntervals.empty())
                        //            {
                        //                predictedInterval = 0;
                        //            }
                        //            else
                        //            {
                        //                predictedInterval = (TGameCycle)(percentileRev(puIntervals, PREDICTION_REV_PERCENTILE) + 1);
                        //
                        //                //if ( predictedInterval > 100 )
                        //                //	nlwarning( "Slot %hu: Predicted interval %u exceeds 100 ticks", (uint16)slot, predictedInterval );
                        //
                        //                if (PosUpdatePredictionGraph)
                        //                    PosUpdatePredictionGraph->addOneValue(slot, (float)predictedInterval);
                        //            }
                        //
                        //            //nlinfo( "Slot %hu: Interval=%u Predicted=%u", (uint16)slot, latestInterval, predictedInterval );
                        //
                        //            /*
                        //             * Add into the changes vector
                        //             */
                        //            CChange thechange(slot, PROPERTY_POSITION, timestamp );
                        //            thechange.PositionInfo.PredictedInterval = predictedInterval;
                        //            thechange.PositionInfo.IsInterior = interior;
                        //            _Changes.push_back(thechange);
                        //
                        //
                    }

                    currentNode = currentNode.B();
                    msgin.Serial(ref currentNode.BranchHasPayload);
                    if (currentNode.BranchHasPayload)
                    {
                        //            msgin.serialBitAndLog(currentNode->a()->BranchHasPayload);
                        //            if (currentNode->a()->BranchHasPayload)
                        //            {
                        //                CActionSint64* ac = (CActionSint64*)CActionFactory::getInstance()->createByPropIndex(slot, PROPERTY_ORIENTATION);
                        //                ac->unpack(msgin);
                        //
                        //                // Process orientation
                        //                CChange thechange(slot, PROPERTY_ORIENTATION, timestamp);
                        //                _Changes.push_back(thechange);
                        //                if (_DataBase != NULL && (!IgnoreEntityDbUpdates || slot == 0))
                        //                {
                        //                    CCDBNodeBranch* nodeRoot;
                        //                    nodeRoot = dynamic_cast<CCDBNodeBranch*>(_DataBase->getNode(0));
                        //                    if (nodeRoot)
                        //                    {
                        //                        CCDBNodeLeaf* node = dynamic_cast<CCDBNodeLeaf*>(nodeRoot->getNode(slot)->getNode(PROPERTY_ORIENTATION));
                        //                        nlassert(node != NULL);
                        //                        node->setValue64(ac->getValue());
                        //                        if (LoggingMode)
                        //                        {
                        //                            nlinfo("CLIENT: recvd property %hu (%s) for slot %hu, date %u", (uint16)PROPERTY_ORIENTATION, getPropText(PROPERTY_ORIENTATION), (uint16)slot, timestamp);
                        //                        }
                        //                        //nldebug("CLPROPNET[%p]: received property %d for entity %d: %" NL_I64 "u", this, action->PropIndex, action->CLEntityId, action->getValue());
                        //                    }
                        //                }
                        //
                        //                CActionFactory::getInstance()->remove((CAction * &)ac);
                        //            }
                        //
                        //            TVPNodeClient::SlotContext.NetworkConnection = this;
                        //            TVPNodeClient::SlotContext.Slot = slot;
                        //            TVPNodeClient::SlotContext.Timestamp = timestamp;
                        //
                        //            // Discreet properties
                        //            currentNode->b()->decodeDiscreetProperties(msgin);
                    }

                    break; // TODO remove - only decode one for testing  
                }
            }
            catch (Exception e)
            {
                // End of stream (saves useless bits)
                _client.Log.Error("End of stream (saves useless bits) " + e.Message);
            }
        }

        /// <summary>
        ///     manage a generic action - invoke the impulse callback for the action
        /// </summary>
        private void GenericAction(ActionGeneric ag)
        {
            var bms = ag.Get();

            ImpulseCallback?.Invoke(bms);
        }

        /// <summary>
        ///     manage a generic multi part action - generate temporary multipart holder until the action is complete
        /// </summary>
        /// <param name="agmp"></param>
        private void GenericAction(ActionGenericMultiPart agmp)
        {
            while (_genericMultiPartTemp.Count <= agmp.Number)
            {
                _genericMultiPartTemp.Add(new GenericMultiPartTemp());
            }

            _genericMultiPartTemp[agmp.Number].Set(agmp, this);
        }

        /// <summary>
        ///     Probe state - deserialise info from stream
        /// </summary>
        private void ReceiveSystemProbe(BitMemoryStream msgin)
        {
            _latestProbeTime = _updateTime;
            msgin.Serial(ref _latestProbe);
            _latestProbes.Add(_latestProbe);
        }

        /// <summary>
        ///     TODO Stalled state - deserialise info from stream
        /// </summary>
        private void ReceiveSystemStalled(BitMemoryStream msgin)
        {
            _client.GetLogger().Debug("CNET: received STALLED");
        }

        /// <summary>
        ///     Sync state - deserialise info from stream - send ack
        /// </summary>
        private void ReceiveSystemSync(BitMemoryStream msgin)
        {
            _latestSyncTime = _updateTime;
            long stime = 0;
            msgin.Serial(ref _synchronize);
            msgin.Serial(ref stime);
            msgin.Serial(ref _latestSync);

            _client.GetLogger().Debug($"receiveSystemSync {msgin}");

            var checkMsgXml = new byte[16];
            var checkDatabaseXml = new byte[16];

            msgin.Serial(ref checkMsgXml);
            msgin.Serial(ref checkDatabaseXml);

            var xmlInvalid = !checkMsgXml.SequenceEqual(_msgXmlMD5) ||
                             !checkDatabaseXml.SequenceEqual(_databaseXmlMD5);

            if (xmlInvalid && !_alreadyWarned)
            {
                _alreadyWarned = true;
                _client.GetLogger().Warn("XML files invalid: msg.xml and database.xml files are invalid (server version signature is different)");

                _client.GetLogger().Debug($"msg.xml client:{Misc.ByteArrToString(_msgXmlMD5)} server:{Misc.ByteArrToString(checkMsgXml)}");
                _client.GetLogger().Debug($"database.xml client:{Misc.ByteArrToString(_databaseXmlMD5)} server:{Misc.ByteArrToString(checkDatabaseXml)}");
            }

            _msPerTick = 100;

            _currentServerTick = (uint)(_synchronize + _currentReceivedNumber * 2);

            _currentClientTick = (uint)(_currentServerTick - (_lct + _msPerTick) / _msPerTick);
            _currentClientTime = _updateTime - (_lct + _msPerTick);

            SendSystemAckSync();
        }

        /// <summary>
        ///     Receive available data and convert it to a bitmemstream
        /// </summary>
        private bool BuildStream(BitMemoryStream msgin)
        {
            var receiveBuffer = new byte[0];

            if (_connection.Receive(ref receiveBuffer, false))
            {
                StatsReceive(receiveBuffer.Length);

                msgin.MemCpy(receiveBuffer);

                return true;
            }

            // A receiving error means the front-end is down
            ConnectionState = ConnectionState.Disconnect;

            // won't send a disconnection msg because state is already Disconnect
            Disconnect();

            _client.GetLogger().Warn("DISCONNECTION");
            return false;
        }

        /// <summary>
        ///     decode the message header from the stream
        /// </summary>
        private bool DecodeHeader(BitMemoryStream msgin, bool checkMessageNumber = true)
        {
            if (_decodedHeader)
                return true;

            ++_totalMessages;

            msgin.Serial(ref _currentReceivedNumber);
            msgin.Serial(ref _systemMode);

            _meanPackets.Update(_currentReceivedNumber, Misc.GetLocalTime());

            if (!_systemMode)
            {
                msgin.Serial(ref _lastReceivedAck);
            }

            if (!checkMessageNumber)
                return true;

            // todo doesn't work if we receive the packet in bad order or 2 same packet
            if (_currentReceivedNumber > _lastReceivedNumber + 1)
            {
                // we lost some messages...
                _client.Log.Debug($"CNET: lost messages server->client [{_lastReceivedNumber + 1};{_currentReceivedNumber - 1}]");
                _meanLoss.Update(_currentReceivedNumber - _lastReceivedNumber - 1, Misc.GetLocalTime());
            }

            // don't acknowledge system messages and normal messages in
            // because this will disturb impulsion from frontend, that will interpret it as if previous messages were ok
            var ackBool = (!_systemMode && (_connectionState == ConnectionState.Connected || _connectionState == ConnectionState.Synchronize));
            var ackBit = (ackBool ? (uint)1 : 0);

            if (_currentReceivedNumber - _lastReceivedNumber < 32)
            {
                _ackBitMask <<= _currentReceivedNumber - _lastReceivedNumber;
                _ackBitMask |= _lastAckBit << (_currentReceivedNumber - _lastReceivedNumber - 1);
            }
            else
            {
                _ackBitMask = (_currentReceivedNumber - _lastReceivedNumber == 32 && _lastAckBit != 0) ? 0x80000000 : 0x00000000;
            }

            _lastAckBit = ackBit;

            // encode long ack bitfield
            for (var i = _lastReceivedNumber + 1; i < _currentReceivedNumber; ++i)
                _longAckBitField[i & (NumBitsInLongAck - 1)] = false;

            _longAckBitField[_currentReceivedNumber & (NumBitsInLongAck - 1)] = ackBool;

            // no more than NumBitsInLongAck ack in field
            if (_lastAckInLongAck <= _currentReceivedNumber - NumBitsInLongAck)
                _lastAckInLongAck = _currentReceivedNumber - NumBitsInLongAck + 1;

            _lastReceivedNumber = _currentReceivedNumber;

            _decodedHeader = true;

            return true;
        }

        /// <summary>
        ///     Disconnects the Client from the server sending a disconnection packet
        /// </summary>
        public void Disconnect()
        {
            if (ConnectionState == ConnectionState.NotInitialized ||
                ConnectionState == ConnectionState.NotConnected ||
                ConnectionState == ConnectionState.Authenticate ||
                ConnectionState == ConnectionState.Disconnect)
            {
                _client.GetLogger().Warn("Unable to disconnect(): not connected yet, or already disconnected.");
                return;
            }

            SendSystemDisconnection();
            _connection.Close();
            ConnectionState = ConnectionState.Disconnect;
        }

        /// <summary>
        ///     sends system sync acknowledge
        /// </summary>
        private void SendSystemAckSync()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            var sync = (byte)SystemMessageType.SystemAckSyncCode;
            message.Serial(ref sync); // 8
            message.Serial(ref _lastReceivedNumber); // 32
            message.Serial(ref _lastAckInLongAck); // 32

            message.SerialVersion(0); // 8
            uint size = (uint)_longAckBitField.Length;
            message.Serial(ref size); // 32
            int len = (int)(size / 32);
            message.Serial(ref len);
            message.Serial(ref _longAckBitField); // 1024

            message.Serial(ref _latestSync); // 32

            _client.GetLogger().Debug($"sendSystemAckSync {message}");

            _connection.Send(message.Buffer(), message.Length);

            _latestSyncTime = _updateTime;

            StatsSend(message.Length);
        }

        /// <summary>
        ///     sends system Probe acknowledge
        /// </summary>
        private void SendSystemAckProbe()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            var probe = (byte)SystemMessageType.SystemAckProbeCode;
            var numprobes = _latestProbes.Count;

            message.Serial(ref probe);
            message.Serial(ref numprobes);

            for (var i = 0; i < numprobes; ++i)
            {
                var val = _latestProbes[i];
                message.Serial(ref val);
            }

            _latestProbes.Clear();

            _connection.Send(message.Buffer(), message.Length);

            StatsSend(message.Length);
        }

        /// <summary>
        ///     sends system Disconnection acknowledge
        /// </summary>
        private void SendSystemDisconnection()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            byte disconnection = (byte)SystemMessageType.SystemDisconnectionCode;

            message.Serial(ref disconnection);

            if (_connection.Connected())
            {
                try
                {
                    _client.GetLogger().Debug($"sendSystemDisconnection {message}");

                    _connection.Send(message.Buffer(), message.Length);
                    StatsSend(message.Length);
                }
                catch (Exception e)
                {
                    _client.GetLogger().Error($"Socket exception: {e.Message}");
                }
            }

            StatsSend(message.Length);
        }

        /// <summary>
        ///     sends system login cookie
        /// </summary>
        public void SendSystemLogin()
        {
            var message = new BitMemoryStream();

            message.BuildSystemHeader(ref _currentSendNumber);

            byte login = (byte)SystemMessageType.SystemLoginCode;
            message.Serial(ref login);

            // Cookie
            message.Serial(ref _userAddr);
            message.Serial(ref _userKey);
            message.Serial(ref _userId);

            // Language
            message.Serial(ref ClientConfig.LanguageCode);

            _client.GetLogger().Debug($"sendSystemLogin {message}");
            _connection.Send(message.Buffer(), message.Length);

            StatsSend(message.Length);
        }

        /// <summary>
        ///     Sets the cookie for the connection
        /// </summary>
        private void SetLoginCookieFromString(string str)
        {
            var parts = str.Split('|');

            _userAddr = int.Parse(parts[0], NumberStyles.HexNumber);
            _userKey = int.Parse(parts[1], NumberStyles.HexNumber);
            _userId = int.Parse(parts[2], NumberStyles.HexNumber);
        }

        /// <summary>
        /// Send last information without changes (only acknowedges frontend)
        /// </summary>
        public void Send(in uint cycle)
        {
            try
            {
                Debug.Assert(LastSentCycle < cycle);

                LastSentCycle = cycle;

                // if no actions were sent at this cyle, create a new block
                if (_actions.Count != 0 && _actions[^1].Cycle == 0)
                {
                    var block = _actions[^1];

                    block.Cycle = cycle;

                    // check last block isn't bigger than maximum allowed
                    int i;
                    var bitSize = 32 + 8; // block size is 32 (cycle) + 8 (number of actions

                    for (i = 0; i < block.Actions.Count; ++i)
                    {
                        bitSize += ActionFactory.Size(block.Actions[i]);

                        if (bitSize >= 480 * 8)
                            break;
                    }

                    if (i < block.Actions.Count)
                    {
                        throw new NotImplementedException("Send: ActionBlock size is bigger than 480 bit. Thats not implemented yet.");
                    }
                }

                if (ConnectionState == ConnectionState.Connected)
                {
                    SendNormalMessage();
                }
            }
            catch (Exception)
            {
                ConnectionState = ConnectionState.Disconnect;
                Disconnect();
            }
        }

        /// <summary>
        /// Create the message to send to the server
        /// </summary>
        private void SendNormalMessage()
        {
            var message = new BitMemoryStream();

            var systemMode = false;

            message.Serial(ref _currentSendNumber);
            message.Serial(ref systemMode);
            message.Serial(ref _lastReceivedNumber);
            message.Serial(ref _ackBitMask);

            foreach (var block in _actions)
            {
                // if block contains action that are not already stamped, don't send it now
                if (block.Cycle == 0)
                    break;

                if (block.FirstPacket == 0)
                    block.FirstPacket = _currentSendNumber;

                block.Serial(message);

                // Prevent to send a message too big
                //if (message.GetPosInBit() > 480 * 8) // easy version TODO: GetPosInBit does not return the right size (i guess)

                // TODO fix workaround: send only 1 block at a time (to not get disconnected)
                break;
            }

            _client.GetLogger().Debug($"CNET: send normal message Packet={_currentSendNumber} Ack={_lastReceivedAck}");
            _client.GetLogger().Debug($"{message}");

            _connection.Send(message.Buffer(), message.Length);

            StatsSend(message.Length);

            _lastSendTime = Misc.GetLocalTime();

            // TODO _PacketStamps.push_back(make_pair(_CurrentSendNumber, _UpdateTime));

            _currentSendNumber++;
        }

        /// <summary>
        /// Send is temporised, that is the packet may not be actually sent.
        /// We don't care, since:
        /// - this packet has no new data (not ticked send)
        /// - a next send() will send packet if time elapsed enough
        /// - a next send(tick) will really be sent
        /// This way, we can say that at most 15 packets will be delivered each second
        /// (5 send(tick), and 10 send() -- if you take getLocalTime() inaccuracy into account)
        /// </summary>
        internal void Send()
        {
            try
            {
                if (ConnectionState == ConnectionState.Connected && Misc.GetLocalTime() - _lastSendTime > 100)
                {
                    SendNormalMessage();
                }
            }
            catch (Exception)
            {
                ConnectionState = ConnectionState.Disconnect;
            }
        }

        /// <summary>
        ///     TODO updateSmoothServerTick - not that important
        /// </summary>
        private void UpdateSmoothServerTick()
        {
        }

        /// <summary>
        ///     Clear not acknownledged actions in sending buffer
        /// </summary>
        public void FlushSendBuffer()
        {
            _actions.Clear();
        }

        /// <summary>
        /// Buffers an action to be sent at next update (or later updates if network overload occurs)
        /// </summary>
        private void Push(ActionBase action)
        {
            if (_actions.Count == 0 || _actions[^1].Cycle != 0)
            {
                _actions.Add(new ActionBlock());
            }

            _actions[^1].Actions.Add(action);
        }

        /// <summary>
        /// Buffers a bitmemstream, that will be converted into a generic action, to be sent later to the server (at next update).
        /// </summary>
        public void Push(BitMemoryStream msg)
        {
            const int maxImpulseBitSize = 230 * 8;
            const byte invalidSlot = 0xFF;

            var ag = (ActionGeneric)ActionFactory.Create(invalidSlot, ActionCode.ActionGenericCode);

            if (ag == null) //TODO: see that with oliver...
                return;

            var bytelen = msg.Length;
            var impulseMinBitSize = ActionFactory.Size(ag);
            var impulseBitSize = impulseMinBitSize + (4 + bytelen) * 8;

            if (impulseBitSize < maxImpulseBitSize)
            {
                ag.Set(msg);
                Push(ag);
            }
            else
            {
                throw new NotImplementedException("Generic ActionBase is too big to get pushed to the stream.");
            }
        }

        /// <summary>
        /// Return the average billed upload rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        /// <param name="bytes"></param>
        private void StatsSend(int bytes)
        {
            _meanUpload.Update(bytes, Misc.GetLocalTime());
        }

        /// <summary>
        /// Return the average billed download rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        /// <param name="bytes"></param>
        private void StatsReceive(int bytes)
        {
            _meanDownload.Update(bytes, Misc.GetLocalTime());
        }

        /// <summary>
        /// Return the average billed download rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        public float GetMeanDownload()
        {
            return (_meanDownload.Mean(Misc.GetLocalTime()) + 20 + 8 + 14) * 0.008f;
        }

        /// <summary>
        /// Return the average billed upload rate in kbps, including all headers (UDP+IP+Ethernet)
        /// </summary>
        public float GetMeanUpload()
        {
            return (_meanUpload.Mean(Misc.GetLocalTime()) + 20 + 8 + 14) * 0.008f;
        }

        /// <summary>
        /// Return the packet loss average
        /// </summary>
        public float GetMeanPacketLoss()
        {
            var time = Misc.GetLocalTime();
            _meanPackets.Check(time);
            _meanLoss.Check(time);
            var dpk = _meanPackets.Dpk();
            var tloss = _meanLoss.Content;
            return dpk > 0.0f ? Math.Min(100.0f, tloss * 100.0f / dpk) : 0.0f;
        }
    }
}